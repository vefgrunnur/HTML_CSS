
# 2 CSS

## 2.1 Hvað er CSS?

Þegar við höfum skrifað efnið okkar í afskaplega fínu HTML skjali, merkingarbæru og aðgengilegu, langar okkur að ljá það lífi með útliti. Þar sem HTML er _descriptive_ markup mál er því ekki ætlað að tjá útlit en þar kemur CSS inn í myndina.

CSS stendur fyrir [_Cascading Style Sheets_](http://en.wikipedia.org/wiki/Cascading_Style_Sheets) og er _style sheet language_ sem lýsir framsetningu á skjali skrifuðu í markup máli, t.d. HTML, XHTML, XML og SVG. CSS kom fyrst fram á sjónarsviðið árið 1994 þegar [Håkon Wium Lie lagði til _Cascading HTML style sheets_](https://www.w3.org/People/howcome/p/cascade.html). Í tillögunni er farið yfir hvernig vafrinn stjórni að mestu allri birtingu og „the author of HTML documents has no influence over the presentation“, sem var vissulega rétt, fyrir tíma CSS var engin leið til að breyta litum á tenglum!

Þó svo að það væri ekki hægt að breyta litum á tenglum lét fólk það ekki stoppa sig í að nýta það sem í boði var til að lífga upp á vefsíður. Töflur og gegnsæjar gif myndir tröllriðu öllu eftir að [_Creating Killer Websites_](https://www.killersites.com/killerSites/core.html) kom út og fólk gat loksins tjáð sig á vefnum með _hönnun_.

![](../img/strik-2000.jpg "strik.is hannaður með töflum maí 2000, fyrsti vefur til að hljóta hin íslensku vefverðlaun. Skjáskot frá Wayback Machine: https://web.archive.org/web/20000520102751/http://www.strik.is:80/")
> Mynd 1: strik.is hannaður með töflum maí 2000, fyrsti vefurinn til að hljóta hin íslensku vefverðlaun.

Árið 1996 var [CSS 1 staðlað hjá W3C](https://www.w3.org/TR/1999/REC-CSS1-19990111) en átti erfitt uppdráttar fyrstu árin eftir það. Stuðningur í vöfrum var ekki mikill og þegar virkni var útfærð var hún oftar en ekki ósamhæfð milli vafra. CSS 2 staðallinn kom út 1998 og kynnti til leiks `position` eigindið sem leyfði enn frekari stjórn yfir útliti. Stuðningur við CSS hélt þó áfram að vera lítill og ósamhæfður í vöfrum. Vefforritarar létu sér nægja að nota töflur og sáu sumir hverjir ekki ástæðu til að tileinka sér nýja tækni sem ekki var vel studd. [Web Standards Project (WaSP)](http://en.wikipedia.org/wiki/Web_Standards_Project) fór gagngert að þrýsta á vafraframleiðendur til að útfæra CSS rétt samkvæmt staðli og var stofnuð til þess [„CSS Action Committee“](https://archive.webstandards.org/css/) sem einnig gekk undir nafninu „The CSS Samurai“. Partur af því sem þessi hópur gerði var að útbúa viðmiðs útfærslu af CSS sem vafrar gátu hlaðið upp og borið saman við mynd. Þetta próf var kallað _acid test_ og varð til þess að stuðningur fór hægt og rólega að aukast.

![](../img/Acid1_reference.png "Upprunalega acid prófið. Mynd: https://commons.wikimedia.org/wiki/File:Acid1_reference.png")
> Mynd 2: Upprunalega acid prófið.

Þegar þessir staðlar voru orðnir ágætlega studdir í nýlegri vöfrum um aldamótin, var þónokkuð af fólki ennþá að nota eldri, úrelta vafra einsog t.d. Netscape Navigator. Þar sem engin pressa var á notendur til að uppfæra og hlutirnir _virkuðu_ var ennþá stöðnun. Þetta breyttist síðan með _töflulausum_ eða _merkingarfræðilegum_ endurhönnum á Wired árið 2001 og ESPN árið 2003. CSS Zen Garden sem opnaði 2003 sýndi fólk líka hvers CSS var megnugt.

![](../img/css-zen-garden.png "Skjáskot af CSS Zen Garden.")
> Mynd 3: CSS Zen Garden leyfði vefforriturum og hönnuðum að spreyta sig á því að útbúa mismunandi útlit ofan á sama HTML skjalið með CSS.

CSS 2.1 kom fyrst út árið 2004 og innihélt sá staðall aðallega lagfæringar á villum í CSS 2. Brösuglega gekk þó að ná yfir allar villurnar. W3C setti því staðalinn fram en setti aftur í _draft_ og hélt það áfram alla leið til ársins 2011. Af þessu lærði W3C og var CSS 3 sett upp á annan máta. Í staðinn fyrir að gefa út einn stóran staðal með allri virkni sem staðla ætti, er virknin þróuð í einingum. [Í dag eru tugir af einingum í vinnslu](https://www.w3.org/Style/CSS/current-work) og eru þær á hverjum tíma í mismunandi stöðu, hvort sem þær eru draft, candidate recommendation eða proposed recommendation.

![](../img/css3.png "Logo fyrir CSS3")
> Mynd 4: Logo fyrir CSS3

## 2.2 Einfalt, ekki auðvelt

> “You don't need to be a programmer or a CS major to understand the CSS specifications. You don't need to be over 18 or have a Bachelor's degree. You just need to be very pedantic, very persistent, and very thorough.”
– [Understanding the CSS Specifications](http://www.w3.org/Style/CSS/read)

CSS er einfalt að læra en ekki auðvelt að nota. Í grunninn eru þetta nokkrar reglur með einfaldri málfræði sem leyfir okkur síðan að lýsa því hvernig element eigi að birtast. Þar sem það er einfalt að læra á CSS en ekki auðvelt að skrifa CSS til að lýsa því útliti sem óskað er eftir, lenda margir upp á kant við CSS. Vegna þessa eru margir sem sem líta CSS hornauga og kenna því um að ekki gangi vel. Þetta er vert að hafa í huga áður en byrjað er að læra CSS.

![](../img/css_awesome.png "Mynd: óþekkt")
> Mynd 5: CSS grín

Það er líka gott að hafa í huga að þó að CSS sé einfalt er það mjög kröftugt. Flest þau útlit sem við sjáum á vefnum eru smíðuð með CSS (stundum eru myndir eða þrívíddarvirkni notuð til að smíða útlit óháð CSS). Með mikilli þolinmæði má smíða ótrúlega hluti með CSS.

> Think for a moment of all the sites out there on the web. There’s a huge variation in visual style: colour schemes, typographic treatments, textures and layouts. All of that variety is made possible by one simple pattern that describes all the CSS ever written:

> ```selector { property: value; }```

>  That’s it.
– [Resilient Web Design – Chapter 2](https://resilientwebdesign.com/chapter2/)

![](../img/francine.jpg "Mynd: https://github.com/cyanharlow/purecss-francine")
> Mynd 6: Listaverk útfært _aðeins_ með HTML og CSS af [Diana Smith](https://github.com/cyanharlow/purecss-francine)

## 2.3 CSS & HTML

Þar sem CSS er sú tækni sem við notum til að ljá HTML líf þurfum við að tengja saman HTML og CSS. Það eru nokkrar leiðir til þessa:

* Geyma CSS í eigin skrá (með skráarendingunni `css`) og vísa í þá skrá úr HTML með `<link rel="stylesheet" href="path/to/file.css">` í `<head>`. Þessi leið viðheldur algjörum aðskilnaði á milli HTML og CSS og er æskilegasta leiðin.
* `<style>` element í HTML skjali, helst í `<head>`. Elementið inniheldur CSS reglurnar sem texta. Þetta er ekki alveg jafn _hrein_ leið en aðskilur þó CSS frá sniðmálinu
* Öll element hafa `style` global attribute sem leyfir skilgreiningu á CSS beint á elementi. Þetta getur haft sína kosti en ætti **alls ekki** að vera almenna leiðin til að tengja CSS við HTML þar sem þetta bindur útlit við sniðmálið og er litlu betra en að nota `<FONT>`

```css
body {
  background-color: pink;
}
```

```html
<!doctype html>
<html lang="is">
  <head>
    <meta charset="utf-8">
    <title>CSS</title>
    <link rel="stylesheet" href="styles.css">
    <style>
    p {
      font-size: 2em;
    }
    </style>
  </head>
  <body>
    <p>Halló, <span style="text-decoration: italic;">heimur</span></p>
  </body>
</html>
```

Í dæminu að ofan eru allar þrjár leiðirnar notaðar en hreinlegri og betri lausn er að geyma allar þessar upplýsingar um útlit í CSS:

```css
body {
  background-color: pink;
}

p {
  font-size: 2em;
}

span {
  text-decoration: italic;
}
```

```html
<!doctype html>
<html lang="is">
  <head>
    <meta charset="utf-8">
    <title>CSS</title>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <p>Halló, <span>heimur</span></p>
  </body>
</html>
```

Þarna höfum við _refactorað_ fyrra dæmið: breytt uppbyggingu á kóða til hins betra án þess að breyta lokaniðurstöðunni.

## 2.4 Málfræði

Málfræði CSS er einföld, flest það sem við gerum byggist á því að vinna með reglusett sem samanstendur af _selectors_ og _skilgreiningum_:

```css
p {
  color: green;
  margin: 1em;
}
```

Hægt er að setja inn athugasemdir í CSS innan `/*` og `*/`:

```css
p {
  /* þetta er athugasemd */
}
```

### 2.4.1 Selectors

_Selector_ er strengur sem lýsir því hvaða element við viljum að taki við _skilgreiningum_. Sér í lagi getum við skrifað:

* _Type selector_, heiti á elementi, t.d. `p`
* _Universal selector_, öll element, skilgreindur með `*`
  - Getur valdið hægagangi þar sem vafri þarf að skoða flest öll element
* _Attribute selector_, velur element eftir því hvaða attribute eru á því og hvað þau innihalda
* _Class selector_, velur element eftir því hvað `class` attribute inniheldur, notar `.` (punkt)
* _ID selector_, velur element eftir því hvað `id` attribute inniheldur
  - Ekki æskilegt þar sem það lætur selector fá hátt sértækni (specificity) gildi
* _Gervi-klasar_ (pseudo-classes), velur hluti sem ekki er hægt að velja með hinum, einföldu selectorum, notum `:`. Þeir skiptast síðan áfram í nokkra flokka, helst ber að nefna:
  - dýnamískir gerviklasar. Fyrir tengla `:link` ef ekki er búið að heimsækja og `:visited` ef búið er að heimsækja. Fyrir aðgerðir notenda, `:hover` meðan sveimað er yfir element, `:active` ef búið er að velja það, smella á það, `:focus` ef það hefur fókus
  - Gerviklasar fyrir upbyggingu, t.d. `:nth-child()`, `:first-child` eða `:last-of-type`

Hægt er að tengja saman selectors með bili (white space), „>“, „+“ eða „~“:

* ` ` þýðir að seinni selector velur element sem er afkomandi fyrri
* `>` er fyrir _strangt barn_, seinni selector verður að vera barn fyrri
* `+` er fyrir _systkini_, seinni selector velur element sem er systkini sem kemur **beint á eftir** fyrri selector
* `~` er almennur systkina selector, seinni selector velur element sem er syskini fyrri

```css
*              /* öll element */
div            /* öll div */
div p          /* öllu p, afkomendur p */
div > p        /* öll p sem eru börn div */
p + p          /* öll p með p sem fyrra systkyni */
div.foo        /* öll div með class foo */
a:hover        /* öll a sem verið að hovera á */
div#foo        /* öll div með id foo */
div[foo="bar"] /* öll div með attribute foo=bar */
```

### 2.4.2 `at` reglur

_At reglur_ leyfa skilgreiningar á aukaupplýsingum. Þær geta verið fyrir ákveðið gildi, t.d. `@import 'foo.css';` sem innifelur allt CSS úr `foo.css`. Þær geta einnig verið hreiðraðar, innihalda þá CSS reglur sem eru aðeins notaðar við ákveðin skilyrði, t.d.

* `@media` sem skilgreinir að ákveðnar reglur eigi við ákveðna virkni eftir _media query_
* `@supports` er nýleg regla sem leyfir okkur að nota reglur aðeins ef ákveðin CSS virkni er studd

### 2.4.3 Gervi-element

Gervi-element (pseudo-elements) leyfa okkur að velja parta af elementi sem við annars gætum ekki gert. Þau eru skilgreind í selector með `::`.

* `:before/:after` – element sem er fyrir framan/aftan það sem skilgreint er
* `:first-letter` – fyrsti stafur elements
* `:first-line` – fyrsta lína elements

### 2.4.4 Villumeðhöndlun

CSS er hannað til að fyrirgefa minniháttar villur, t.d. fyrir yfirlýsingar:

* Ef tvípunkt eða semíkommu vantar í yfirlýsingu
* Ef heiti eigindis er óþekkt
* Ef gildi er óþekkt eða ekki er hægt að vinna úr því

Er yfirlýsingin öll hunsuð og haldið áfram að næstu.

Meiriháttar villur stoppa lestur á skjali frá þeim stað sem þær eiga sér stað. Þetta gerist yfirleitt þegar `{` og `}` eru ekki í jafnvægi.

```css
p {
  color: blue;

  /* næstu tvær reglur eru hunsaðar, vantar ; */
  color: yellow
  font-size: 10em;
}

/* a verður litað grænt þó } vanti */
a {
  color: green;

/* engar reglur héðan í frá verða nýttar því } vantar */
em {
  color: purple
}
```

### 2.4.5 Skilgreiningar

Skilgreiningar á reglusetti eru innan `{` og `}` innihalda enga eða fleiri _yfirlýsingar_ aðgreindar með semikommu.

Yfirlýsing byrjar á nafni _eigindis_, tvípunkti, _gildi eigindis_ og loks endar semíkomma yfirlýsinguna. `eigindi: gildi;`

Nöfn eiginda eru margvísleg í CSS og bætast við fleiri eftir því sem ný virkni er skilgreind. Gildin eru hinsvegar töluvert færri.

Fyrir sum eigindi er hægt að skilgreina í einni yfirlýsingu mörg gildi fyrir svipaða virkni, þetta er kallað _shorthand_. Þessi virkni getur minnkað fjölda lína sem við þurfum að skrifa og kannski sparað tíma.

Shorthand leyfir líka að sleppa því að skilgreina ákveðin gildi og eru þá sjálfgefin gildi sett í staðinn. Þetta getur valdið vandræðum ef það skrifar yfir gildi sem við höfum áður skilgreint.

## 2.5 Gildi í CSS

Strengir er skilgreindir með `'` eða `"`. Ef við þurfum að skrifa þess stafi notum við _escape_, með því að setja `\` fyrir framan.

* `"this is a 'string'"`
* `"this is a \"string\""`

Url skilgreinum við með `url(<slóð>)` þar sem slóð er bein slóð eða slóð í streng.

* `url(http://example.org)`
* `url('http://example.org')`

Liti má skilgreina með:

* Lykilorði, t.d. `black`, `white`, `green`
  - `transparent` er einnig lykilorð fyrir alveg gegnsæan lit
* RGB gildi með hexadecimal (eða hex) eða `rgb()`, t.d. `#00ff00` eða `rgb(0, 255, 0)` (bæði gildi eru grænn). Hex gildi má einnig skilgreina með þrem stöfum, en þá gildir hver stafur tvisvar, `#0f0` er `#00ff00`, `#9ac` er `#99aacc`
  - RGB gildi skilgreina styrkleika á rauðum (red), grænum (green) og bláum (blue) frá `0` og upp í `255` í decimal kerfi eða `0` uppí `ff` í hex
* [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) gildi með `hsl()`

Hægt er að skilgreina alpha rás fyrir lit ef `rgba` eða `hsla` er notað. Ef gildið er `1` er liturinn ekkert gegnsær, ef `0.5` er liturinn hálfgegnsær og ef `0` er liturinn að öllu gegnsær.

Tölur geta verið heiltölur og rauntölur. Rauntölur eru skilgreindar með punkt, t.d. `1.2`. Einingar á tölum geta verið ýmsar en einnig getum við skilgreint prósentur, t.d. `25.5%``. Tölur notum við yfirleitt þegar við vinnum með _lengdir_ í CSS.

## 2.6 Lengdir

Þegar unnið er með útlit í CSS er mikið unnið með lengdir. Hvort sem það er til að stýra hversu breið, há eða hve mikið bil er á milli elementa. Eigindin geta tekið hinar ýmsu einingar. Í grunninn eru þær hlutfallslegar og nákvæmar.

Eitt sérstakt gildi er hægt að gefa fyrir lengd en það er `auto` sem leyfir vafra að reikna lengdina fyrir element.

### 2.6.1 Nákvæmar einingar

Nákvæmar einingar eiga við þegar við vinnum með hluti sem við vitum nákvæmar mælingar á, t.d. fyrir prent þar sem við prentum á þekkta stærð í raunheimum, þar er hægt að nota einingar einsog `in`, `cm`, eða `mm`. Að skilgreina `1cm` í CSS þýðir samt ekki að útkoman verði nákvæmlega einn sentimeter útprentuð. Nákvæma gildið er alltaf _hlutfallslegt_ við upplausn prentunar, `dpi` eða _dots per inch_.

Í langflestum tilfellum reynum við að sleppa því að nota nákvæmar einingar þar sem vafrinn og umhverfið sem vefurinn okkar birtist í er ekki þekkt stærð. Þó eru aðstæður þar sem við þurfum að nota nákvæmar einingar og þá notum við `px` eða _pixel_. Það er þó töluvert flóknara en svo að `1px` í kóða sé `1px` á öllum tækjum.

### 2.6.2 Hlutfallslegar einingar

Hlutfallslegar einingar skiptast í tvo hópa, letur-hlutfallslegar einingar (font-relative lengths) og skjá-prósentu einingar (viewport percentage lengths).

Letur-hlutfallslegar einingar horfa til `font-size` eigindsins þegar þær skilgreina stærð fyrir element. Yfirleitt notum við `em` eða `rem` einingar. `em` var upphaflega stærð skilgreind útfrá breidd `M` í leturgerð en hefur í dag verið skilgreind í CSS sem stærð `font-size`. Ef ekkert hefur verið átt við `font-size` er `1em == 16px` en ef `font-size: 18px;` hefur verið skilgreint verður `1em == 18px`.

Þegar reiknað er úr `em` gildum í elementum sem eiga sér foreldri með skilgreint `em` gildi eru þau _margfölduð_. Þetta getur oft valdið ruglingi þegar `em` er notað:

```css
html { font-size: 1.5em; }
/* texti innan html er núna 16px * 1.5 = 24px */

.foo { font-size: 12px; }
/* texti innan .foo er nákvæmlega 12px */

.foo p { font-size: 2em; }
/* texti í p undir .foo er 12px * 2 = 24px */

.foo p em { font-size: 10px; }
/* texti í em undir p undir .foo er nákvæmlega 10px */

.foo p strong { font-size: 1.5em; }
/*
  texti í strong undir p undir .foo er:
  12px * 2 * 1.5 = 36px
*/
```

Núna spyrja margir sig, afhverju í ósköpunum að hafa svona flækjustig í útreikningum á stærðum fyrir texta? Þetta er svona flókið þar sem við getum með þessu útbúið vefi þar sem _vertical rhythm_ eða _lóðréttur hrynjandi_ í texta er réttur. Öll bil og allar stærðir eru margfeldi af grunnstærð.

`rem` einingin losar okkur við þessa margföldun í gegnum element og horfir alltaf á stærð rótar elements, `font-size` á `<html>`. Þar með getum við fengið kosti þess að skilgreina hlutfallslega án þess að þurfa að vera í sífellu að reikna hlutföll.

![](../img/vertical-grid.jpg "Síða sem nýtir grid og vertical rhythm. Mynd: https://www.smashingmagazine.com/2012/12/css-baseline-the-good-the-bad-and-the-ugly/")
> Mynd 7: Síða sem nýtir grid og vertical rhythm.

Ástæðan fyrir því að nota hlutfallslegar einingar er, einsog áður var nefnt, til að hjálpa okkur að láta vefinn okkar birtast rétt í þeim mýmörgu tækjum sem hann getur verið skoðaður í. Ef við fastsetjum allar stærðir útfrá stórum skjám með háa upplausn munu einstaklingar sem skoða hann á minni skjám með minni upplausn lenda í vandræðum, og öfugt.

Nánar má lesa um einingar í [MDN: CSS <length>](https://developer.mozilla.org/en/docs/Web/CSS/length), [CSS-Tricks: The Lengths of CSS](https://css-tricks.com/the-lengths-of-css/) og [W3C: Font-relative lengths](http://www.w3.org/TR/css3-values/#font-relative-lengths).

Skjá-prósentu einingar eru hlutfallslegar við stærð _viewports_ sem er yfirleitt stærð vafragluggans.

* `vw` er ein eining á breiddina (_viewport width_) svo `100vw` myndi fylla upp í skjá á breiddina
* `vh` er ein eining á hæðina (_viewport height_) svo `100vh` myndi fylla upp í skjá á hæðina
* `1vmin` er `1vw` eða `1vh`, hvort sem er minna
* `1vmax` er `1vw` eða `1vh`, hvort sem er stærra

Hægt er að nota þessar einingar bæði til að stýra stærðum á elementum eða öðru, t.d. leturstærð.

## 2.7 Dæmi um selectors og einingar

Fyrir eftirfarandi HTML

```html
<div>
  <p>Halló <strong id="text">heimur</strong></p>
</div>

<div class="text">
  <em>Lorem</em> <span foo>ipsum <em foo>dolor</em> sit amet</span>, consectetur adipiscing elit.
</div>
```

skilgreinum við CSS

```css
html { font-size: 20px; }
/* grunn stærð fyrir em er 20px */

div { border: 1px solid #000; }
/* svartur 1px breiður border */

em { color: #f00; }
/* látum öll em vera með rauðan texta */

div > em { color: #00f; }
/* en ef þau eru beint undir div er það blátt */

div + div { margin-top: 1em; }
/* div sem er systkini div fær 20px margin fyrir ofan sig */

div.text:first-letter { font-size: 2em; }
/* fyrsti stafur undir div.text verður 10px*2=20px */

[foo]::after { content: ' foo!'; }
/* á eftir öllum elementum með attribute foo setjum við textan foo! */

span:hover { background-color: #0f0; }
/* ef við förum með mús yfir span breytir það um bakgrunnslit */
```

## 2.8 Specificity – sértækni

Hvernig veit síðan vafrinn nákvæmlega hvaða gildi fyrir hverja eigindu eigi að nota þegar útlitið er teiknað? Byrjað er á að finna allar CSS reglur og fyrir hvern  selector er reiknað _sértækni_ (specifitcy) sem er á forminu `a,b,c,d` þar sem:

* `a`, 1 ef skilgreint í `style` attribute, annars 0
* `b`, fjöldi `id` selectora
* `c`, fjöldi attribute selectora og gervi-klasa
* `d`, fjöldi elementa og gervi-elementa

Við fáum síðan gildi með því að skeyta gildinu saman í tölu sem er sértækni gildið. Þetta gildi, ásamt öðru, ræður því hvaða reglur eru notaðar.

```css
li.foo {}        /* a=0 b=0 c=1 d=1 → 11 */
#foo {}          /* a=0 b=1 c=0 d=0 → 100 */
.foo .bar:active /* a=0 b=0 c=3 d=0 → 30 */
style=""         /* a=1 b=0 c=0 d=0 → 1000 */
```

## 2.9 Cascade – „flóðið“

Þegar útlit er sett saman af því sem ætlar að birta útlit þarf að komast að því _nákvæmlega_ hvaða skilgreiningar eigi við fyrir hvert element. Þá er „flóðið“ eða cascade notað. Skilgreiningar geta komið frá þremur stöðum:

* _User agent_, tæki sem birtir (yfirleitt af vafra, en fleiri tæki styðja CSS) en það verður að skilgreina sjálfgefna stíla
* _Notanda_, notandi tækis getur skilgreint með stillingum hvernig hlutir líta út, t.d. að allt sé stækkað
* _Höfundi_, skilgreiningar frá höfundi vefs, yfirleitt okkar sem vefforritara

Eftir að allt CSS hefur verið lesið frá öllum upprunum er skilgreiningum raðað eftir:

1. Skilgreiningum user agents
2. Skilgreiningum notanda
3. Skilgreiningum höfundar
4. Skilgreiningum höfundar merktar með `!important`
5. Skilgreiningum notanda merktar með `!important`
6. Sértækni
7. Skilgreiningar röð innan skjals þar sem seinna skilgreint fær hærra gildi

Þessi röðun er síðan notuð til að reikna hvaða gildi hver yfirlýsing fær.

### 2.9.1 `!important`

Með því að skilgreina `!important` á yfirlýsingar höfum við áhrif á það hvar í röðinni yfirlýsingin lendir. Þetta gæti hljómað sem góð hugmynd en í raun er hún það ekki. Yfirlýsingar með `!important` hunsa sértækni gildi og skilgreiningar röð og vinna því gegn almennu reglunni um það hvernig reiknað er og getur valdið rugling.

```css
div {
  font-size: 100px !important;
  /* það er mjög mikilvægt að allur texti sé 100px! */
}
```

T.d. ef tveir aðilar vinna í sama CSS, annar lendir í einhverjum vandræðum með að fá rétt útlit með því að nota selectora og setur `!important` á yfirlýsingu. Hinn aðilinn hefur verið að nota rétta selectora til að fá fram útlit en allt í einu hætta þær skilgreiningar að vera réttar því `!important` gildi tekur yfir skilgreiningar.

### 2.9.2 Gildi

Þegar útlit er birt þarf að reikna gildi fyrir allar yfirlýsingar sem tæki styður. Til þess er byrjað á að finna skilgreint gildi eftir reglu:

* Ef „flóðið“ gefur okkur gildi, notum það
* Annars, erft gildi
* Annars, upphafsgildi

Sum gildi eru erfð í börnum frá foreldri sínu, þetta sparar okkur heilmikla vinnu og lætur CSS virka einsog við myndum gera ráð fyrir.

```html
<h1>Halló <em>heimur</em></h1>
```

```css
h1 { color: blue; }
/*
  allur texti innan h1 er blár, líka sá
  sem er innan em, þar sem color erfist
*/
```

Fyrir aðrar yfirlýsingar eru skilgreind upphafsgildi. Þau eru yfirleitt rökrétt en stundum geta þau valdið okkur vandræðum, sérstaklega þegar við notum _shorthand_. T.d. er `background-color` með sjálfgefna gildið `transparent`, engin bakgrunnslitur.

Þegar komið er að því að fá raun gildi er það fengið með eftirfarandi reglu:

* Reiknað gildi – reiknað úr hlutfallslegum gildum eins langt og hægt er, t.d. hlutfallsleg breidd m.v. foreldri
* Notað gildi – fáum nákvæm gildi úr öllum, leyst úr háðum gildum
* Raun gildi – gildi notað við birtingu, t.d. þarf að námunda tölur að einhverjum aukastaf

```html
<section>
  <div>halló</div>
</section>
```

```css
html {
  font-size: 10px;
}

section {
  width: 10em;
  /* reiknað, notað og raun gildi: 10px * 10 = 100px */
}

div {
  font-size: 2em;
  /* reiknað, notað og raun gildi: 10px * 2 = 20px */

  border: 0.01em solid black;
  /*
  reiknað og notað gildi: 0.01 * 20px = 0.2px
  raun gildi: 1px, rúnað upp
  */

  width: auto;
  /*
  reiknað gildi: auto
  notað gildi: 100px, búið að reikna section
  raun gildi: 98px, útfrá box model og border
  */
}
```

### 2.9.3 Reset

Hver user agent (í flestum tilfellum vafri) setur sín eigin sjálfgefnu gildi sem eru notuð ef við skilgreinum ekkert. Þetta getur verið mismunandi milli vafra og því varð hugtakið um _css reset_ til, en það eru reglusett sem setur öll element í „núllstöðu“. Fyrsta [`reset.css` skjalið](http://meyerweb.com/eric/tools/css/reset/) var búið til af Eric Meyer.

## 2.10 Að skrifa CSS

Algengasta leiðin til að skrifa CSS er að hafa einn selector per línu með `{` á línu seinasta selectors. Allar yfirlýsingar eru síðan dregnar inn innan reglusetts.

```css
/* ekki svona */
.foo, .bar, div { font-size: 1em;
color: black; }

/* heldur svona */
.foo,
.bar,
div {
  font-size: 1em;
  color: black;
}
```

Almennt notum við ekki ID selectora þar sem þeir hafa hærra specifity en class selector og valda því vanda. Einnig ætti `id` aðeins að vera skilgreint einu sinni fyrir element per síðu og því ekki hægt að endurnýta fyrir fleiri. Þetta þýðir þó ekki að við notum `id` aldrei, þegar við vissulega viljum finna einstök element með JavaScript getum við notað `id`.

```css
#foo .bar { font-size: 2em; }

/*
  getum ekki náð hærra specificity nema með því að nota líka id
  eða fara út í að nota !important
*/
.bar { font-size: 1.5em; }
```

Einnig er æskilegt að nýta sér „flóðið“ þar sem það á við, t.d. til að skilgreina leturgerð aðeins einu sinni, þarf ekki að skilgreina aftur og aftur fyrir mörg element.

Stundum eru yfirlýsingum raðað á einhvern sérstakan hátt og þeim hópað saman, t.d. allt sem á við texta saman, allt sem á við staðsetningu. Þetta á sérstaklega við í verkefnum sem margir vinna í.

Þegar við skrifum `class` á element til að velja með selector þá er venjan að skrifa þá með _kebab-case_ á ensku:

```css
/* ekki svona */
.MikilvaegurTexti
.ListOfItems

/* heldur svona */
.important-text
.list-of-items
```

_Kebab-case_ er ein af nokkrum leiðum til að skrifa samsett orð án bila en sú þörf kemur oft upp í forritun þegar bil hefur merkingu. Í CSS er bil leið til að sameina selectors svo velja þarf einhverja leið til að útbúa samsett orð. Aðrar leiðir eru t.d.

* lowerCamelCase
* UpperCamelCase
* snake_case
* Upper_Snake_Case

Eins og með annað sem viðkemur kóðastíl er mikilvægt að gæta samræmis.

## 2.10.1 CSS validation

W3C heldur úti [_validation_ þjónustu](https://jigsaw.w3.org/css-validator/) sem bæði bendir okkur á beinar villur en einnig hugsanlega vandræði sem CSS gæti skapað. Til þess að fá allar upplýsingar þurfum við að kveikja á öllum _warnings_ undir _more options_.

Fyrir eftirfarandi CSS:

```css
p {
  font-size: 1en;
  margim: 1em;
}

.foo {
  background-color: #999;
}
```

fáum við villur:

```
2 p Value Error : font-size Unknown dimension 1en
3 p Property margim doesn't exist : 1em
```

og viðvaranir:

```
7 You have no color set (or color is set to transparent) but you have set a background-color. Make sure that cascading of colors keeps the text reasonably legible.
```

## 2.11 Box model

Box módelið lýsir því hvernig rétthyrnd box fyrir element eru mynduð.

![](../img/boxdim.png "Útskýringar mynd af box modelinu. Mynd: http://www.w3.org/TR/CSS2/box.html")
> Mynd 8: Útskýringar mynd af box modelinu.

### 2.11.1 Margin

Margin er ysta lag boxsins og getum við skilgreint lengd í hverja átt með `margin-top`, `margin-right`, `margin-bottom` og `margin-left`. Lengd getur verið skilgreind sem neikvæð tala en þá er box _dregið_ í viðkomandi átt um töluna. Litur á boxi er ekki settur á margin svæði box.

Ef `auto` er skilgreint fyrir vinstri og hægri hliðar er box miðjað í foreldri sínu, vafri reiknað sjálfkrafa hve mikið margin á að vera báðum megin.

_Shorthand_ skilgreining á margin er:

```css
margin: 1em; /* margin: allar hliðar; */
margin: 1em 0; /* margin: top&bottom right&left; */
margin: 0 1em 2em; /* margin: top right&left bottom; */
margin: 0 1em 2em 3em; /* margin: top right bot left; */
```

Lóðrétt margin tveggja eða fleiri boxa í röð geta fallið saman og er það kallað _collapsing margin_. Einnig getur það gerst fyrir box innan í boxi. Getur oft komið á óvart en getur líka verið gagnlegt. Nokkuð [flóknar reglur](http://www.w3.org/TR/CSS2/box.html#collapsing-margins) segja til um hvenær og hvernig það gerist.

```html
<p>foo</p>
<p class="bar">bar</p>
<p>baz</p>
```

```css
p { margin: 50px; }
/*
á milli tveggja p er aðeins 50px margin
ekki 50px+50px þar sem þau collapse'a saman
*/

.bar { margin-bottom: 100px; }
/*
milli p.bar og næsta p er 100px margin ekki 100px + 50px, einnig collapse
*/
```

### 2.11.2 Border

Border er næst ystalag boxins og teiknar jaðar utan um það. Hægt er að skilgreina:

* þykkt (width) sem jákvætt tölulegt gildi með `border-width`
* stíl (style) með lykilorðum, t.d. `solid` (lína), `dotted` (teiknaður jaðar er röð af punktum), `double` (tvær línur með bili á milli, summa alls er jafn þykkt) með `border-style`
* lit (color) sem litagildi með `border-color`

Fyrir hverja átt er hægt að skilgreina hvert gildi, t.d. `border-top-width`. Eða notað `border` shorthand sem skilgreinir allt fyrir allar hliðar eða per hlið með t.d. `border-top`.

```css
border: 1px solid #000; /* svört 1px lína allt um kring */
border-top: 0; /* nema engin lína efst */
border-bottom-width: 3px; /* og 3px þykk í botninum */
border-left-style: dotted; /* og punktar til vinstri */
```

### 2.11.3 Padding

`padding` er næst innsta lag boxsins en það er skilgreint einsog `margin` en getur ekki fengið neikvætt gildi. Fær bakgrunnslit sem skilgreindur er á elementi. `padding` hefur eins shorthand og `margin`.

### 2.11.4 Boxið

Við getum skilgreint breidd með `width` og hæð með `height` fyrir efnið. Heildarstærð sem boxið tekur er þá:

```
width = left margin + right margin + left border + right border +
        left padding + right padding + content width

height= top margin + bottom margin + top border + bottom border +
        top padding + bottom padding + content height
```

Það getur leitt til vandræða þar sem útlit notar hlutfallslegar stærðir og nákvæmar stærðir, t.d. ef við skilgreinum border með `px` en viljum að boxið í heild sinni fylli alveg upp í foreldri sitt með `100%`.

Að takmarka hæð á elementum er hættulegur leikur. Breidd á elementum miðast alltaf við breidd á vafra (eða því tæki sem við erum að skoða með) og því auðveldara að takmarka það og þá sérstaklega með hlutfallslegum lengdum. `width: 100%;` á element þýðir að það fyllir upp í lárétt pláss foreldris. Í flestum tilfellum viljum við því takmarka breidd en láta hæðina flæða eftir því sem efnið þarf.

```html
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam eleifend nunc non suscipit finibus. Proin non tincidunt nisl. Quisque lacus nibh, sodales in felis aliquet, iaculis pellentesque sem.</p>
```

```css
p {
  border: 1px solid #000;
  width: 10%;
  height: 100px;
}
```

Því minna pláss sem foreldri bíður upp á, því meiri líkur á að textinn „flæði út úr“ `p` elementinum.

### 2.11.5 Box sizing

CSS3 skilgreinir [`box-sizing`](https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing) sem breytir því hvernig box modelið er reiknað

* `content-box;` - sjálfgefið gildi, allt tekið með í reikninginn
* `border-box;` - aðeins margin er tekið með í reikninginn

### 2.11.6 Takmarkanir á hæð og breidd

Stundum viljum við að boxin okkar séu aldrei minni eða stærri en ákveðið á hæð eða breidd

* `min/max-height: X;` takmarkar box þ.a. það sé aldrei minna/stærra en X
* `min/max-width: X;` takmarkar box þ.a. það sé aldrei mjórra/breiðara en X

Þetta getur verið gott þegar við vinnum með hluti sem _skalast_ en við vitum að undir/yfir ákveðinni breidd verða þeir ljótir eða ónothæfir, þá getum við skilgreint breidd þeirra í hlutfallslegri stærð, t.d. `width: 100%;` en takmarkað þá með `min-width` og `max-width`.

```html
<div class="box">
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam eleifend nunc non suscipit finibus. Proin non tincidunt nisl. Quisque lacus nibh, sodales in felis aliquet, iaculis pellentesque sem. Maecenas elit orci, dictum at congue non, elementum sit amet magna. Aliquam erat volutpat. Aenean magna erat, faucibus eu hendrerit sed, pharetra sed mauris. Fusce et dui urna. Vivamus sollicitudin mollis rutrum. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Vivamus hendrerit volutpat erat a maximus. Sed pharetra dapibus sapien ac bibendum.
</div>
```

```css
.box {
  box-sizing: border-box;

  width: 100%;     /* fyllir upp í foreldri */
  max-width: 40em; /* aldrei breiðari en um 40em, ca þ.a. við höfum 50-60 stafi í línu */
  min-width: 20em; /* og aldrei minni en um 20em */

  padding: 1em;
  border: 1px solid #000;
}
```

### 2.11.7 Dæmi

```html
<div class="outer-box">
  <div class="inner-box">
    Efni í boxi
  </div>
</div>

<div class="border-box">
  <div class="outer-box">
    <div class="inner-box">
      Efni í boxi
    </div>
  </div>
</div>

<div class="fluid-box border-box">
  <div class="outer-box">
    <div class="inner-box">
      Efni í boxi
    </div>
  </div>
</div>
```

```css
/* box model */
.outer-box {
  background: #669;

  border: 1px solid blue;
  padding: 10px;

  width: 200px;
}

/* viljum box sem fyllir upp í foreldri sitt en hefur samt pláss */
.outer-box .inner-box {
  background: #fff;
  width: 100%; /* = 200px þar sem parent er 200px */
  height: 100px;
  padding: 20px 30px;
  border: 2px solid #000;

  /* heildarstærð á boxi er þá:
      width: 200px + 2*30px + 2*2px = 264px
      height: 100px + 2*20px + 2*2px = 144px
  */
}

.border-box {
  margin-top: 100px;
}

/*
ef við skilgreinum sem border-box er efnið aðlagað
þ.a. padding og border eru með í útreikingi á víddum
*/
.border-box * {
  box-sizing: border-box;
}

/*
Með border-box getum við auðveldlega búið til box sem geta
komist fyrir og fyllt upp í foreldri sitt
*/
.fluid-box > .outer-box {
  width: 100%;
  min-width: 200px;
  max-width: 500px;
}
```

Þegar við byrjum að vinna með útlit í CSS er mjög gott að muna það að **lang flest í CSS er rétthyrnt box!**

## 2.12 Visual formatting model

CSS 2.1 skilgreinir [_visual formatting model_](http://www.w3.org/TR/CSS2/visuren.html) sem er grunnurinn í því hvernig við vinnum með útlit síðu. Þar til _flexbox_ náði nægilegra mikilli útbreiðslu voru þessar aðferðir þær einu sem notaðar voru til að stilla upp öllu útliti.

_Visual formatting model_ tekur til:

* Gerð boxa
  - `block` vs. `inline` og `display` eigindið
* Eðlilegs flæðis
* Staðsetningu með `position`
* Þriðju víddarinnar
* Float

### 2.12.1 Normal flow – eðlilegt flæði

Ef við höfum ekki skilgreint hvernig element á að haga sér er það í _eðlilegu flæði_ og er sjálfgefið annað hvort _block_ eða _inline_

* _block_ element forma blokkir og fylla upp í breidd foreldris
* _inline_ element forma ekki blokkir heldur dreifir sér í línur, inline element fá ekki lárétt `margin`, `width` eða `height`

`display` eigindið leyfir okkur að stýra því hvernig element hagar sér m.t.t. eðlilegs flæðis. Einnig er hægt að skilgreina fleiri gildi, t.d.

* `inline-block`, element myndar blokk (og getur því fengið lárétt margin) en dreifir sér í línu
* `none`, element er fjarlægt með öllu úr flæði og hefur ekkert pláss

```html
<div class="box block">block</div>
<div class="box inline-block">inline block</div>
<div class="box inline">inline</div>
<div class="box none">none</div>
<div class="box block">block</div>
<div class="box inline-block">inline block</div>
```

```css
.box {
  width: 50px;
  height: 50px;

  margin: 20px;
  border: 2px solid #f00;
  padding: 20px;

  background-color: #000;
  color: #fff;
}

.block { display: block; } /* stendur alltaf sér í blokk */
.inline { display: inline; } /* raðast í línu með öðrum inline eða inline-block */
.inline-block { display: inline-block; } /* raðast í línu með inline */
.none { display: none; } /* hvergi sjáanlegt */
```

Ef við viljum ekki ganga svo langt að fjarlægja box með `display: none;` getum við falið allt efni innan þess með `visibility: hidden;`. Það felur boxið og allt efni í því en reiknar með því í útliti.

### 2.12.2 Efni í boxi

Þegar við stýrum stærð á elementum með `height` eða `width` hættum við á að það verði of lítið fyrir efni sitt. Þá getur `overflow` hjálpað en það leyfir okkur að skilgreina hvað gerist við efnið sem flæðir út fyrir:

* `visible` (sjálfgefið) sýnir efni sem flæðir út fyrir
* `hidden` felur efni sem flæðir út fyrir
* `scroll` efnið flæðir og skrunstikur birtast
* `auto` birtir efni ef pláss, annars skrunstikur

Í þeim tilfellum sem við takmörkum hæð á elementum sem innihalda texta þá viljum við hugsa sérstaklega um `overflow`. Það er auðvelt að gera ráð fyrir því að texti muni alltaf vera jafn langur og sá sem við höfum í forritun, en hvað gerist ef einhver bætir við tvisvar sinnum lengri texta? Eða ef fyrirsögn er það löng að hún fari í tvær línur? `overflow: hidden` er ódýr lausn sem viðheldur útliti en felur efni. `overflow: auto` setur sjálfkrafa þær skrunstikur sem verða að vera og er yfirleitt besta lausnin.

## 2.13 Staðsetning

Við getum stýrt staðsetningu á elementum með `position` eigindinu. Það tekur nokkur lykilorð sem stýra hvernig við viljum breyta staðsetningu. Ásamt því notum við `top`, `right`, `bottom` og `left` eigindin (stundum kölluð _offset eigindi_) til þess að staðsetja, en þau taka öll bæði jákvæð og neikvæð gildi sem lengd. `static` er sjálfgefna gildi `position` og staðsetur það í eðlilegu flæði. Að gefa element `position` gildi annað en `static` gerir það að _containing block_ sem notast er við í suma útreikninga. Fyrsta containing block er rótar elementið, yfirleitt `<html>`.

### 2.13.1 Hlutfallsleg staðsetning

`position: relative;` staðsetur element _hlutfallslega_ í eðlilegu flæði. Staðsetning er reiknuð út frá eðlilegu flæði en síðan er það flutt hlutfallslega miðað við þá staðsetningu. Eftir flutning er „plássið“ í eðlilegu flæði eftir.

```html
<div class="box">1</div>
<div class="box">2</div>
<div class="box">3</div>
<div class="box">4</div>
```

```css
.box {
  margin-bottom: 10px;
  padding: 20px;
  height: 50px;
}

.box:nth-child(2) {
  position: relative;
  top: 150px;
  left: 50px;
}

.box:nth-child(4) {
  position: relative;
  top: -200px;
  left: -50px;
}
```

![](../img/pos-relative.png "Box 2 er flutt niður og til vinstri. Box 4 er flutt upp í pláss box 2 og dregið út úr foreldri til vinstri með neikvæðu gildi. Bæði er reiknuð fyrst í eðlilegu flæði og fá breidd þaðan og skilja eftir sig pláss.")
> Mynd 9: Box 2 er flutt niður og til vinstri. Box 4 er flutt upp í pláss box 2 og dregið út úr foreldri til vinstri með neikvæðu gildi. Bæði er reiknuð fyrst í eðlilegu flæði og fá breidd þaðan og skilja eftir sig pláss.

### 2.13.2 Nákvæm staðsetning

`position: absolute;` staðsetur element _nákvæmlega_ útfrá containing block og hunsar eðlilegt flæði. Element sem eru staðsett nákvæmlega eru ekki reiknuð í eðlilegu flæði og skilja því ekki eftir sig pláss.

```html
<div class="absolute">
  <div class="box">1</div>
  <div class="box">2</div>
  <div class="box">3</div>
  <div class="box">4</div>
</div>
```

```css
.absolute {
  /* gerum foreldri að containing block */
  position: relative;
  border: 1px solid #000;
}

.box {
  margin-bottom: 10px;
  padding: 20px;
  height: 50px;
}

.box:nth-child(1) {
  position: absolute;
  top: 0;
  right: 0;
}

.box:nth-child(3) {
  position: absolute;
  bottom: 0;
  left: 50px;
  width: 100px;
}
```

![](../img/pos-absolute.png "Foreldri er containing block svo staðsetning miðast við box þess. Box 1 er flutt í efra hægra horn, það fær ekki stærð þar sem það er ekki reiknað í eðlilegu flæði. Box 3 er staðsett í botni 50px frá vinstri og gefin 100px breidd.")
> Mynd 10: Foreldri er containing block svo staðsetning miðast við box þess. Box 1 er flutt í efra hægra horn, það fær ekki stærð þar sem það er ekki reiknað í eðlilegu flæði. Box 3 er staðsett í botni 50px frá vinstri og gefin 100px breidd.

Með því að nota `position: absolute;` getum við látið element _fylla út í_ foreldri sitt að öllu leiti með því að tilgreina öll staðsetningar eigindi í `0`. Foreldri **verður** að vera containing block, annars er barnið staðsett ofar í trénu.

```css
.fill {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

.parent {
  position: relative;
}
```

```html
<div class="box">
  <div class="child">
    Box 1 – barn
  </div>
</div>
<div class="box parent">
  <div class="child fill">
    Box 2 – barn
  </div>
</div>
```

![](../img/pos-absolute-filled.png "Barn í boxi 2 fyllir alveg út í foreldri sitt þar sem það er containing block.")
> Mynd 11: Barn í boxi 2 fyllir alveg út í foreldri sitt þar sem það er containing block.

### 2.13.3 Föst staðsetning

`position: fixed;` staðsetur element _fast_ útfrá viewport og hunsar eðlilegt flæði. Element sem eru fast staðsett eru ekki reiknuð í eðlilegu flæði og skilja því ekki eftir sig pláss. Element er fast að því leiti að þegar síða er _scrolluð_ helst element í stað.

```css
.fixed { // element er alltaf staðsett uppi í vinstra horni vafra
  position: fixed;
  top: 0;
  left: 0;
}
```

### 2.13.4 Klístruð staðsetning

`position: sticky;` _klístrar_ element með samblandi af hlutfallslegri og fastri staðsetningu. Staðsetning er reiknuð út frá eðlilegu flæði en þegar komið er að ákveðnum þröskuldi á _containing block_ sem getur skrunað, þá er það reiknað sem það væri hlutfallslega fast.

```css
.sticky {
  /* staðsett hlutfallslega þangað til... */
  position: sticky;

  /* 200px frá top á containing block sem skrunar, þá fast */
  top: 200px;
}
```

### 2.13.5 Þriðja víddin

Element sem hafa annað gildi en `position: static;` eru ekki aðeins staðsett í tvívíðu rúmi, þau liggja líka á z-ás. Þetta kemur fram t.d. í því að ef tvö eða fleiri element eigi að birtast í efra vinstra horni, hvert þeirra sést? Þessi staðsetning ræðst af _stacking order_ og hvernig það er reiknað út sjálfgefið fylgir [ákveðnum reglum](https://www.w3.org/TR/CSS2/visuren.html#z-index). Við getum ákvarðað hvar í röðinni element liggur með því að gefa því sitt eigið gildi með `z-index: <tala>;`. Hærra `z-index` gildi raðar element _nær_ notanda þ.e.a.s. ofar á z-ás.

```html
<div class="zindex">
  <div class="box">1</div>
  <div class="box">2</div>
  <div class="box">3</div>
  <div class="box">4</div>
</div>
```

```css
.zindex {
  position: relative;
  border: 1px solid #000;
}

.zindex .box:nth-child(1) {
  position: absolute;
  top: 60px;
  right: 0;
  z-index: 4;
}

.zindex .box:nth-child(2) {
  position: relative;
  z-index: 1;
}

.zindex .box:nth-child(3) {
  position: absolute;
  bottom: 50px;
  left: 50px;
  z-index: 1;
  width: 100px;
}

.zindex .box:nth-child(4) {
  position: relative;
  z-index: 3;
}
```

![](../img/pos-absolute-zindex.png "Box 1 liggur ofan á öllum öðrum boxum en box 3 liggur ofan á boxi 2 en undir boxi 4.")
> Mynd 12: Box 1 liggur ofan á öllum öðrum boxum en box 3 liggur ofan á boxi 2 en undir boxi 4.

Eitt sem getur valdið vandræðum með `z-index` er þegar við viljum birta element _innan_ elements sem hefur skilgreint `z-index` og hefur systkini sem hafa sama `z-index`, fyrir utan það. T.d. ef við viljum birta upplýsingar þegar _hoverað_ er yfir eitthvað eða smellt á takka í lista af boxum. Boxin hafa sama `z-index` og reglur segja til um að seinna í DOM trénu (þ.e.a.s. seinna í HTML röð) hefur forgang í birtingu ef sama `z-index` gildi er skilgreint.

![](../img/z-index-hover.png "Texti sem birtist þegar hoverað er yfir texta liggur undir boxi sem kemur á eftir og hefur sama z-index")
> Mynd 13: Texti sem birtist þegar hoverað er yfir texta liggur undir boxi sem kemur á eftir og hefur sama z-index

## 2.14 Floats

Önnur leið sem CSS 2.1 skilgreinir til að hafa áhrif á eðlilegt flæði er með _floats_ en það getum við skilgreint fyrir element með `float` eigindinu sem getur tekið gildin `left`, `right` eða sjálfgefna gildið `none`. Með því að skilgreina `float: left;` eða `float: right;` fjarlægjum við element úr eðlilegu flæði og „fleytum“ því til vinstri eða hægri m.v. þá línu sem það er í. Þessi lína er efri brún staðsetningar elements í eðlilegu flæði áður en því er fleytt. Fleiri en eitt element sem fleytt er í sömu átt munu sitja hlið við hlið lárétt svo lengi sem þau hafa pláss. Um leið og plássið er ekki til staðar mun elementi vera ýtt niður og „ný“ lína myndið.

```html
<div class="img">mynd</div>
<p>Lorem ipsum dolor sit amet…</p>
```

```css
.img {
  float: left;
  margin: 0 10px 10px 0;
}
```

![](../img/float.png "„Mynd“ er fleytt til vinstri og liggur við hliðina á texta.")
> Mynd 13: „Mynd“ er fleytt til vinstri og liggur við hliðina á texta.

Við getum stýrt flæðinu í kringum element sem er fleytt með `clear` eigindinu sem tekur við gildunum `left`, `right`, `both` eða sjálfgefna gildinu `none`. Ef við „hreinsum“ ekki innan foreldris, sem aðeins inniheldur element sem er fleytt, getum við lent í vandræðum þar sem það fær þá ekki hæð og fellur saman (collapses). Nokkrar leiðir eru til að koma í veg fyrir þetta en sú sem var vinsælust meðan `float` var meira notað var _clearfix_ sem er sett á foreldrið og útbýr gervi-element á eftir því sem sér um að hreinsa.

```css
.clearfix::after {
  content: '';
  display: table;
  clear: both;
}
```

Á einum tímapunkti var `float` töluvert notað til þess að stýra heildar útliti á síðum, t.d. til að fleyta dálki til vinstri o.þ.h. Í dag ættum við ekki að nota `float` til að stýra útliti heldur aðeins til að fleyta elementum innan annars efnis, t.d. myndum sem eiga við texta.

Þar með ljúkum við sérstakri yfirferð yfir CSS 2.1 og förum yfir virkni eftir hópum. Einhver virkni þar gæti verið úr CSS 1, CSS 2.1 eða einhverju af CSS 3 módúlum. En þá gæti spurningin um hvaða virkni getum við treyst á að sé studd af vöfrum? Getum við notað virkni _án þess_ að hún sé að fullu studd? Þurfa allir vefir að líta eins út?

## 2.15 Progressive enhancement

Hugtakið um _progressive enhancement_ segir að við eigum að einbeita okkur að upplifun sem krefst minnstu mögulegrar tækni og bæta hana í lögum, _progressively_. Á hverju af þessum _lögum_ nær notandi að upplifa efnið okkar.

Þetta má hugsa í tilfelli vefforritunar svona:

1. Skrifum áhugavert, skýrt efni
2. Setjum það upp með aðgengilegu, merkingarfræðilegu HTML
3. Bætum við grunn útliti sem er vel stutt
4. Bætum við flóknara útliti sem er e.t.v. minna stutt
5. Bætum við aukinni virkni með JavaScript

Með hverju skrefi verður vefurinn _fallegri_, _skemmtilegri_ og meira _töff_ fyrir einhverjar skilgreiningar af þessum orðum.

![Progressive Enhancement lýst með M&M](../img/m-m.jpg "Progressive Enhancement lýst með M&M")
> Mynd 14: Progressive Enhancement lýst með M&M

### 2.15.1 Nýleg virkni í CSS

Ný veftækni (einsog t.d. CSS 3) er ekki að fullu studd í öllum vöfrum sem notaðir eru dagsdaglega. Við viljum því ekki nota þá virkni blint ef það getur á einhvern hátt dregið úr upplifun notenda. Það eru nokkrar leiðir til að skrifa CSS með þetta allt saman í huga.

Auðveld leið er að skilgreina _fallback_ gildi, en það er gildi sem við eru viss um að allir vafrar styðji áður en við skilgreinum gildi sem nýtir nýrri tækni sem ekki er að fullu studd.

```css
width: 99%;
width: calc(100% - 30px);
```

`calc()` er fall í CSS sem leyfir okkur að reikna saman lengdir sem hafa mismunandi lengdir. T.d. getum við reiknað `calc(50% - 2px);` og m.v. hvað `50%` verður reiknað sem, verða `2px` dregnir frá þeirri stærð þegar notað gildi er fundið.

Önnur leið sem vafraframleiður bjóða upp á er að nota _vafraforskeyti_ (vendor prefixes) á ákveðnum eigindum og gildum. Þá er boðið upp á virknina áður en vafrinn er með fullkominn stuðning eða á meðan staðallinn er ekki að fullu skilgreindur. Þetta hefur farið minnkandi seinustu ár þar sem vefforritarar uppfærðu ekki endilega vefi eftir að forskeyti urðu óþarfi og vafri varð að halda áfram að styðja það.

```
display: -webkit-box;
display: -ms-flexbox;
display: flex;

-webkit-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
```

Ekki er æskilegt að handskrifa vafraforskeyti heldur nota sjálfvirk tól til að sjá um, t.d. [_autoprefixer_](https://autoprefixer.github.io/).

Báðar þessar leiðir nýta sér villumeðhöndlun CSS, eigindi og gildi sem ekki eru þekkt af vafra er einfaldlega sleppt og næsta er skoðað.

[caniuse.com](http://caniuse.com/) hefur yfirgripsmikinn gagnagrunn yfir stuðning vafra á ákveðinni virkni. Við getum nýtt okkur þennan gagnagrun til að taka ákvörðun um það hvort það sé þess virði að leggja í að nota nýja virkni yfir höfuð fyrir verkefnið okkar.

![](../img/caniuse-grid.png "Stuðningur við CSS Grid á caniuse.com. Mynd: skjáskot af caniuse.com, september 2018")
> Mynd 15: Stuðningur við CSS Grid á caniuse.com í september 2018

### 2.15.2 _Feature queries_

Nýlegri leið til að skrifa CSS sem ekki er tryggt að allir vafrir styðja er að nota _feature queries_ með `@supports` at-reglunni. `@supports` leyfir okkur að athuga hvort að eigindi **og** gildi séu studd, þá getum við innan reglunnar skilgreint CSS sem er notað. Það ber þó að fara sparlega með notkun á þessu og ætti aðeins að nota ef við þurfum að skrifa fleiri en eina línu af CSS, hugsanlega með nýrri virkni og eldri í bland. Ef við ætlum einfaldlega að bæta við virkni í einni línu þá notum við fallback.

```css
/* ef við getum breytt því í hvaða átt texti er skrifaður með writing mode
   gerum það *og* fleytum texta til vinstri */
@supports (writing-mode: vertical-lr) {
  h1 {
    float: left;
    writing-mode: vertical-lr;
  }
}
```

```css
/* ekki gera svona, bara bæta við border-radius sem progressive enhancement */
@supports (border-radius: 50%) {
  .box {
    border-radius: 50%;
  }
}
```

### 2.15.3 Shim og polyfill

Almennt er talað um _shim_ sem virkni sem „stungið“ er inn í umhverfi til þess að veita nýja virkni í gömlu umhverfi (eða öfugt, gamalli virkni í nýrra umhverfi). Þegar umhverfið er síðan uppfært ætti _shim_ virknin að detta út og allur kóði ætti að virka í nýja umhverfinu. Þessi virkni er e.t.v. ekki alveg kórrétt eða hröð, en hún veitir fyrr aðgang að nýrri virkni.

Fyrir vefinn er talað um _polyfill_ sem kóða sem veitir aðgang að nýrri virkni áður en allir vafrar bjóða upp á hana, þ.e.a.s. polyfill er shim fyrir vafra virkni. Polyfill eru ekki eingöngu fyrir CSS virkni heldur eru til polyfill fyrir mikið af virkni sem komið hefur til á seinustu árum og koma einhversskonar stuðningi í jafnvel elstu vafra, sjá t.d. [HTML5 Cross Browser Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills).

### 2.15.4 CSS og progressive enhancement

Við getum notað _í dag_ virkni sem verður ekki að fullu studd í öllum vöfrum fyrr en _í framtíðinni_ og við höfum plan um hvernig. Í því plani tökum við tillit til þess að:

* Ákveða hvaða vafra og stýrikerfi við ætlum (eða ætlum ekki að styðja)
* Prófa í viðeigandi tækjum
* Nýta okkur _progressive enhancement_

### 2.15.5 Prófanir í öllum vöfrum

Yfirleitt vinnur vefforritari í sínum uppáhalds textaritli og þróar vefi með hjálp síns uppáhalds vafra. Þessi vafra er eflaust með góð _developer tools_ sem hjálpa til við forritunina, og góðan stuðning við nýlega virkni. Þetta á hinsvegar ekki við um alla sem nota vefinn. Í gegnum árin hafa mjög margir mismunandi vafrar verið gefnir út með mjög mismunandi stuðning við HTML, CSS og JavaScript. Á seinni árum með sjálfvirkum uppfærslum hefur þó dregið töluvert úr þessu.

Þegar kemur að því að ákveða hvaða vafra eigi að styðja (og það er gott að ákveða sem fyrst í ferlinu) er mikilvægt að gera sér grein fyrir því að með hverjum vafra sem þarf að prófa í eykst tíminn sem verkefnið tekur. Þessi auka tími getur verið lítill fyrir einfaldari verkefni eða mikill fyrir flóknari. Þegar inn í þetta spila einnig mismunandi tæki er mikilvægt að hafa plan. Ein leið til að útbúa svona plan er að skoða heimsóknartölur fyrir núverandi vef til að fá tilfinningu fyrir því hvaða vafra notendur séu að nota. Ef það er ekki möguleiki má skoða hvaða vafra fólk er að nota í því svæði sem verkefnið verður mest notað.

Á vefurinn okkar að virka í Internet Explorer sem hefur 1,8% markaðshlutdeild á Íslandi og 3% hnattrænt (skv. [mælingum statcounter í ágúst 2018](http://gs.statcounter.com/browser-market-share/all/worldwide/2018))? Hvað með [Opera Mini](https://en.wikipedia.org/wiki/Opera_Mini), vafri sem mikið er notaður í löndum þar sem gagnamagn á farsímaneti er dýrt og takmarkað?

Það sem er mikilvægast eftir að búið er að útbúa plan um hvaða stuðning við ætlum að hafa er að komast í raun útgáfur af tækinu til að prófa í. Hvort sem það er að hafa sér tölvu með  windows stýrikerfinu til að prófa verkefnið í Internet Explorer og Edge í, eða tölvu með macos stýrikerfinu til að prófa í Safari. Einnig eru til þjónustur eins og [Browserstack](https://www.browserstack.com/) sem leyfir okkur að tengjast úr vafranum okkar við sýndarumhverfi sem keyrir mjög margar útgáfur af stýrikerfum og vöfrum.

![](../img/browserstack.png "Skjáskot af stýrikerfum og vöfrum í boði á browserstack í september 2018")
> Mynd 16: Skjáskot af stýrikerfum og vöfrum í boði á browserstack í september 2018

## 2.16 Letur

Þegar við birtum texta er mikilvægt að huga að leturgerð og hvernig textinn er birtur, hvort sem það er sem meginmál, fyrirsagnir eða á einhvern annan hátt. CSS hefur mörg eigindi sem skilgreina hvernig það er gert.

### 2.16.1 Leturgerð

Leturgerð segir til um hvaða hönnun á letri við notum til að birta texta. Í grunninn höfum við aðgang að almennum leturgerðum:

* serif, letur með þverendum
* sans-serif, letur án þverenda
* cursive, letur sem lítur út fyrir að vera handskrifað
* monospace, letur þar sem allir stafir eru jafnbreiðrir
* fantasy, ævintýralegt letur

og _vef öruggum_ (web safe) leturgerðum sem aðgengilegar eru á lang flestum tækjum:

* „Times New Roman“, serif týpa
* „Georgia“, serif týpa
* „Arial“ (sem ætti að skilgreina með Helvetica), sans-serif týpa
* „Verdana“, sans-serif týpa
* „Courier new“, monospace týpa

![](../img/typefaces.png "Mismunandi leturgerðir og vef öruggar leturgerðir")
> Mynd 17: Mismunandi leturgerðir og vef öruggar leturgerðir

Við nýtum síðan `font-*` eigindi til að velja og breyta hvernig leturgerðin hagar sér:

* `font-family` skilgreinir hvaða leturgerðir við notum sem forgangsröðuðum lista af strengjum skiptum með `,` (kommu) sem ætti alltaf að enda á vef öruggri leturgerð
* `font-style`, sjálgefið `normal`, skásetur letur með gildinu `italic`
* `font-variant` setur ýmsar breytur á leturgerð, t.d. að setja texta í `small-caps`
* `font-weight` setur þyngd letur í tölum (t.d. `700`) eða heitum (t.d. `bold`)
* `font-size` setur stærð leturs
* `line-height` setur hæð línu (hlutfall af leturstærð), skilgreint án einingar

```css
p {
  font-family: helvetica, arial, sans-serif;
  font-style: italic;
  font-variant: small-caps;
  font-weight: bold;
  font-size: 1em;
  line-height: 1.5;
}
```

`font` er shorthand sem skilgreinir mörg af þessum gildum í einu:

```css
/* font: (style|variant|weight) size/line-height family; */
font: italic small-caps bold 1em/1.5 helvetica, arial, sans-serif;
```

Þegar við viljum setja textann okkar á _baseline_ og fylgja _vertical rhythm_ eða _lóðréttum hrynjanda_ þurfum við að passa upp á hver og einasta lína og bil á milli þeirra séu margfeldi af grunnstærðinni okkar. Þessi grunnstærð er sett sem einhver tala sem við verðum síðan að fylgja í öllum útreikningum, til þess að geta séð að við séum að fylgja kerfinu okkar er hægt að setja inn línur sem hjálpa okkur að sjá kerfi.

```html
<h1>Fyrirsögn sem situr á baseline</h1>
<p>
  Pellentesque habitant morbi tristique senectus et netus et malesuada
  fames ac turpis egestas. Proin a dictum metus, non aliquam justo.
  Vivamus nulla nisl, ultrices eu odio non, consequat faucibus justo.
  Phasellus magna dui, faucibus sit amet massa ullamcorper, pellentesque
  bibendum lorem. Ut tincidunt lobortis sollicitudin.
</p>

<h2>Millifyrirsögn á baseline</h2>
<p>
  Pellentesque habitant morbi tristique senectus et netus et malesuada
  fames ac turpis egestas. Proin a dictum metus, non aliquam justo.
  Vivamus nulla nisl, ultrices eu odio non, consequat faucibus justo.
  Phasellus magna dui, faucibus sit amet massa ullamcorper, pellentesque
  bibendum lorem. Ut tincidunt lobortis sollicitudin.
</p>
```

```css
html, body {
  /* grunnstærð, það sem rem mun reikna út frá */
  font-size: 20px;
}

h1 {
  /* leturstærð er 3*20px = 60px */
  font-size: 3rem;

  /*
  línu hæð er 2 * 60px = 120px sem er 3 * 40, passar innan baseline
  Texti verður miðjaður innan línu
  */
  line-height: 2;

  /* ekkert margin, line height sér um að viðhalda bili */
  margin: 0;
}

h2 {
  /*
  leturstærð á millifyrirsögn er 1.5 * 20px = 30px
  sem er í lagi því við verðum að passa að línan sé margfeldi af 20
  */
  font-size: 1.5rem;

  /* setjum í línuhæð, 40/30 = 1.33333333 */
  line-height: 1.3333333;
  margin: 0;
}

p {
  /* textastærð er 1rem * 20px = 20px */
  font-size: 1rem;

  /* línuhæð er 2 * 20px = 40px */
  line-height: 2;

  /* texti hefur 2rem * 20px = 40px margin að neðan */
  margin: 0 0 2rem;
}
```

![](../img/baseline.png "Texti sem situr á baseline")
> Mynd 18: Texti sem situr á baseline

### 2.16.2 Aðrar leturgerðir

Með `@font-face` at reglunni getum við sótt aðrar leturgerðir og gert þær aðgengilegar í CSS. Við skilgreinum hvað leturgerðin heitir og hvernig hún hagar sér (er hún italic eða bold o.s.fr.) og, hvar hana er að finna og á hvaða formi.

```css
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 400;
  src: url(path-to-font) format('woff2');
}
/* skilgreinum aðrar gerðir, t.d. italic, í öðrum @font-face blokkum */
```

Nokkrar þjónustur bjóða upp á ókeypis leturgerðir:

* [Google Fonts](https://fonts.google.com/) hefur mörg hundruð leturgerðir í boði og býður upp á hýsingu svo einfalt er að byrja að nota þær leturgerðir
* [Font Squirrel](https://www.fontsquirrel.com/) hefur einnig margar leturgerðir í boði en hægt er að sækja þær leturgerðir

## 2.17 Texti

Við getum breytt útliti á texta:

* `text-transform` stýrir hvort texti sé aðeins í hástöfum (`uppercase`), lágstöfum (`lowercase`) eða hver stafur í hástöfum (`capitalize`)
* `text-decoration` stýrir strikun gegnum texta, `underline`, `overline` eða `line-through`
* `letter-spacing` stýrir hversu mikið bil er milli hvers stafs, yfirleitt sett í `em`, þ.a. `letter-spacing: 1em;` setur eitt leturbil milli hvers stafs. Neikvæð tala dregur texta saman
* `text-shadow` setur skugga á letur `text-shadow: offset-x | offset-y | blur-radius | color` þar sem `offset` gildi segja til um hversu mikið skuggi er dreginn eftir x eða y ás

Texta er hægt að skipta upp í dálka með _columns_. Við tilgreinum hámarksfjölda dálka sem við viljum skipta textanum í með `column-count` og hversu breiðir þeir mega í minnsta lagi vera með `column-width`. Vafrinn reiknar síðan út hvernig dálkar birtist best m.v. stærð foreldis, glugga o.s.fr. `column-gap` getur einnig tekið lengd og er þá pláss á milli dálka, `column-rule` getur skilgreint línu sem skiptir dálkum.

```css
section {
  columns: 3 14em;
  column-gap: 2em;
  column-rule: inset 1px #999;
}
```

`writing-mode` eigindið leyfir okkur að stilla það hvort texti sé teiknaður lóðrétt eða lárétt og hvar hann byrjar.

```css
writing-mode: horizontal-tb; /* sjálgefið, lárétt frá vinstri til hægri, lóðrétt frá toppi til botns */
writing-mode: vertical-rl; /* lárétt hægri til vinstri, lóðrétt frá toppi til botns */
writing-mode: vertical-lr; /* lárétt vinstri til hægri, lóðrétt frá toppi til botns */
```

## 2.18 Prent CSS

Við getum haft áhrif á það hvernig vefirnir okkar prentast út með CSS. Það á helst við síðan sjálf hefur mikið af óþörfum elementum fyrir prentun, t.d. valmynd eða fótur eða stýra því hvar síða má skiptast, t.d. viljum við ekki að mynd prentist á tveim síðum. Bæði er hægt að vísa sérstaklega í prent css með `<link rel="stylesheet" media="print" href="print.css">` eða nota at-reglu:

```css
@media print {
  nav,
  footer {
    display: none; /* ekki birta valmynd eða fót */
  }

  img {
    page-break-inside: avoid; /* forðast að prenta myndir á tveim síðum */
  }
}
```

## 2.19 Bakgrunnur og litir

Þegar við vinnum með myndir í CSS er það sem bakgrunnur á element. Við tilgreinum hvaða mynd á að birta og stillum síðan birtinguna á henni

* `background-color` setur lit á bakgrunn, sjálfgefið gildi er gegnsætt (transparent)
* `background-image` setur mynd á bakgrunn eftir slóð
* `background-repeat` segir til um hvernig bakgrunnurinn endurtekur sig
  - `repeat` og hann endurtekur sig á báðum ásum
  - `repeat-x` og `repeat-y` skilgreina endurtekningu á einum ás
* `background-attachment` skilgreinir hvernig bakgrunnur hagar sér í skrolli – með (scroll) eða fastur (fixed)
* `background-position` skilgreinir hvar myndin birtist
  - Lykilorð (`right`, `left`, `top`, `bottom`, `center`), nákvæmum einingum eða hlutföllum
* `background-size` skilgreinir hvernig fara eigi með stærð myndar innan elements, þar ber helst að nefna:
  - `background-size: contain` skalar mynd þannig að hún verði eins stór og mögulegt sé án þess að teygja eða klippa af mynd
  - `background-size: cover` skala mynd í að vera eins stór og mögulegt sé en ef hún fyllir ekki út í element er hún klippt lóðrétt eða lárétt til að hún passi

`background` er shorthand sem skilgreinir mörg af þessum gildum í einu:

```css
/* background: [color] [image] [repeat] [attachment] [position] */
background: #fff url(bg.png) no-repeat left top; /**/
```

Við getum skilgreint _stigul_ (gradient) sem bakgrunn á element en það eru litir sem blandast saman eftir ákveðnum formerkjum. Vafrar hafa mismunandi útfærslur og þarf að skilgreina með vafraforskeytum og gott að nota tól, t.d. [Ultimate CSS Gradient Generator](http://colorzilla.com/gradient-editor/).

`color` breytir lit á texta elements.

### 2.19.1 Gegnsæi

Með `rgba()` og `hsla()` getum við stýrt því hversu gegnsæir litir eru frá, `0` alveg gegnsætt upp í `1` ekki gegnsætt.

Við getum einnig stýrt því hversu gegnsætt allt efni í elementi er með `opacity` sem tekur tölu frá `0` og upp í `1`. Oft notum við `opacity` þegar við erum að láta eitthvað birtast eða hverfa á vefnum okkar. Einnig getum við notað `opacity` til að útbúa mjög mikið gegnsætt lag yfir myndir sem við ætlum að setja texta ofan á. Það gerir það að verkum að þó svo að myndin breytist muni textinn alltaf vera sýnilegur (t.d. ljós texti ofan á mynd með miklu hvítu).

```css
.half-opaque {
  /* bakgrunnslitur er hálf gegnsær en allur texti mun vera ógegnsær */
  background-color: rgba(0, 0, 0, 0.5);
  color: #fff;
}

.protection {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;

  /* 80% gegnsæ vörn sem hægt er að setja ofan á mynd svo texti sjáist */
  background-color: rgba(255, 255, 255, 0.2);
}

.almost-all-opaque {
  /* allt efni í elementi er næstum alveg gegnsætt */
  opacity: 0.1;
}
```

### 2.19.2 Bakgrunnur í stað texta

Stundum höfum við element sem inniheldur texta en útlitslega viljum við birta mynd og hafa stjórn með CSS, t.d. logo í staðinn fyrir heiti fyrirtækis. Það væri einfaldlega hægt að hafa tómt element og bæta síðan myndinni á með CSS en aðgengislega gengur það ekki. Við getum haldið textanum á sínum stað til að hann sé lesinn en [falið hann sjónrænt með CSS trikkum](http://www.zeldman.com/2012/03/01/replacing-the-9999px-hack-new-image-replacement/).

```css
.hide-text {
  text-indent: 100%;
  white-space: nowrap;
  overflow: hidden;
}
```

## 2.20 CSS variables

CSS variables leyfa okkur að skilgreina breytur, t.d. fyrir lit, ákveðna lengd eða eitthvað annað sem er mikið notað. Þetta leyfir okkur að gera breytingar á auðveldari máta og getur bætt lesanleika. Breyturnar eru skilgreindar með `--<heiti>` en það er vegna þess að þær nýta sömu hugsun og í vafraforskeytum og eru í raun að nota _tóma_ forskeytið. Til þess að nýta breytu notum við `var(--<heiti>)` fallið í CSS. Ef breyta er ekki skilgreind getum við sent aðra færibreytu sem er þá _fallback_ gildi, `var(<breyta>, #000)`. Breytur sem skilgreindar eru munu erfast frá foreldri til barns og eru háðar _cascade_.

```html
<h1>Halló <span>heimur</span></h1>
<p><span>bless</span></p>
```

```css
h1 {
  --main-color: #f0f;
  color: var(--main-color);
}

span {
  color: #000;
  /* ef við höfum aðgang að breytu er hún notuð, annars #000 */
  background-color: var(--main-color, #0f0);
}
```

![](../img/css-vars.png "Litum stýrt með CSS breytum")
> Mynd 19: Litum stýrt með CSS breytum

Til þess að skilgreina breytur alveg efst í trénu svo hún sé aðgengileg öllu getum við notað `:root` gerviklasann (pseudo-class). Þessi gerviklasi er alltaf jafngildur rótinni á skjalinu sem er verið að stíla. Fyrir HTML væri það eins og að skilgreina fyrir `html` nema `:root` hefur hærri sértækni.

```css
:root {
  --main-color: #f0f;
}
h1 {
  color: var(--main-color);
}
```

Aðrir hlutir sem við getum gert með CSS breytum:

* Breytt dýnamískt gildi með því að setja breytu með `style` attribute
* Margfaldað tölulegt gildi breytu með `calc()`, t.d. `calc(--multiplier * 1em)`
* Skilgreint mörg gildi í einu, t.d. `--margins: 10px 20px;`, `margin: var(--margins);`

## 2.21 Annað

### 2.21.1 Border radius

Hægt er að rúnna horn á boxi með `border-radius`, það virkar hvort sem `border` hafi verið skilgreindur eða ekki. Líkt og með `border` er `border-radius` shorthand fyrir `border-top-left-radius` o.s.fr.

Ef við skilgreinum eina tölu er miðað við hringlaga horn en tvær tölur miða við sporöskjulaga horn.

Hægt er að nota [border-radius generator frá Mozilla](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Background_and_Borders/Border-radius_generator) til að skilgreina hin fullkomnu rúnuðu horn.

### 2.21.2 Box shadow

Líkt og með skugga á texta getum við skilgreint einn eða fleiri skugga á boxum.  Þessir skuggar geta bæði legið utan (`outset`, sjálfgefið gildi) eða innan boxsins (`inset`). Við skilgreinum hvernig skugginn liggur frá boxinu á x og y ás, hversu mikið hann er _bluraður_, hvernig hann dreifist og hvernig hann er á litinn. Fyrir flóknari skugga má nota [box-shadow generator frá Mozilla](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Box-shadow_generator).

### 2.21.3 CSS shapes

Þar sem lang flest í CSS er skilgreint sem rétthyrnt box getur verið skemmtilegt að brjóta upp þessi box og gera eitthvað öðruvísi. CSS shapes leyfa okkur skilgreina hvernig inline element leggjast upp að boxunum okkar, í staðinn fyrir að nota ytra byrði þeirra. Við getum skilgreint form (t.d. hring, polygon) eða _alpha channel_ á mynd, þau svæði myndar sem eru gegnsæ. Í dag er hægt að nota í einhverjum vöfrum `shape-outside` sem leyfir að gera þetta fyrir efni utan boxa, en unnið er að skilgreiningu á `shape-inside`.

```css
img {
  float: left;
  shape-outside: ellipse(50% 50%); /* efni leggst eftir sporöskjulaga ferli utan um myndina */
  margin: 1em;
}
```

![](../img/shapes.png "Texti legst upp að mynd með gegnsæan hluta")
> Mynd 19: Texti legst upp að mynd með gegnsæan hluta

### 2.21.4 `object-fit`

Þegar við fellum inn annað efni á síðuna okkar, eins og mynd með `<img>` þá gætum við þurft að skilgreina hvernig það meðhöndlað til að passa í foreldri sitt. Með `object-fit` getum við skilgreint nokkrar leiðir til að meðhöndla:

* `object-fit: fill;`, sjálfgefið, fyllir algjörlega út í foreldir. Ef stærðarhlutföll (aspect ratio) passar ekki, er hlutur teygður
* `object-fit: cover;`, hlutur fyllir út í box en stærðarhlutföllum er haldið, ef hlutur passar ekki er klippt af honum
* `object-fit: contain;`, hlutur fyllir út í box en stærðarhlutföllum er haldið, ef hlutur passar ekki er hann skalaður, getur myndast „letterbox“
* `object-fit: none;`, ekkert er átt við hlut

Einnig er hægt að stýra staðsetningu hlutar í tvívíðu rúmi með `object-position: <x-ás> <y-ás>;`. Sjálfgefið gildi er `object-position: 50% 50%;`, hlutur er miðjaður.

![](../img/object-fit.png "Dæmi um hvernig object-fit kemur mynd fyrir, mynd er skilgreind til að vera nákvæmlega 600x200")
> Mynd 20: Dæmi um hvernig object-fit kemur mynd fyrir, mynd er skilgreind til að vera nákvæmlega 600x200

## 2.22 Flexbox

Það kom snemma í ljós að noktun á visual formatting model með `position`, `float` og félögum var ekki nóg til að gera flókin útlit. Sérstaklega getur verið erfitt að nota það til að útbúa útlit þar sem hlutir voru jafn háir eða eru miðjaðir lóðrétt innan foreldris. Flexbox var búið til með það að leiðjarljósi að einfalda gerð flókinna útlita.

Í júli 2009 kom fyrsta útgáfa af staðlinum sem kynnti til leiks `display: box;` sem síðan í mars 2011 breyttist í `display: flexbox;` sem að lokum endaði í `display: flex;` árið 2012 þegar fyrsta candidate recommendation kom út. Stuðningur við flexbox (með vafraforskeytum) er í dag mjög mikill og er aðalleiðin til þess að útbúa útlit í dag.

Flexbox er skilgreint með því að setja `display` eigindið `display: flex;` en þá er element í eðlilegu flæði og börnum þess er raðað með flexbox. Einnig er hægt að setja `display: inline-flex;` en þá er element túlkað _inline_ í eðlilegu flæði en börnum þess raðað með flexbox. Þegar börnum elements er raðað með flexbox er `margin` á alla gleypt með `auto`, ekki bara lárétt.

Börn elements sem er raðað með flexbox eru kölluð _flex items_. Þau raðast sjálfgefið í þeirri röð sem þau eru skilgreind í HTML en við getum breytt þeirri röðun með `order` eigindinu. Hægt er að skilgreina `order` fyrir hvert flex item og er þeim síðan raðað þar sem hærri tala raðar flex item seinna. Sjálfgefið gildi er `order: 0;`.

### 2.22.1 Ásar

![](../img/flex-direction-terms.svg "Ásar í flexbox. Mynd: W3C")
> Mynd 18: Ásar í flexbox.

Í flexbox eru skilgreindir tveir ásar, aðalás (main axis) og krossás (cross axis) sem eru hornréttir á hvorn annan. Með því að nota `flex-direction` getum við skilgreint aðalásin:

* `flex-direction: row;`, sjálfgefið gildi, aðalás frá vinstri til hægri (eða hægri til vinstri ef texti er lesinn þannig)
* `flex-direction: row-reverse;`, aðalás frá hægri til vinstri
* `flex-direction: column;`, krossás (m.v. `row`) verður skilgreindur sem aðalás og öfugt. Aðalás frá toppi til botns
* `flex-direction: column-reverse;`, einsog `column` en aðalás frá botni til tops

Sjálfgefið er öllum flex itemum troðið á aðalás og þau minnka í samræmi til að fá pláss. Hægt er að nota `flex-wrap` til að láta flex item flæða í nýja flex-línu ef ekki er nóg pláss:

* `flex-wrap: nowrap;`, sjálfgefið, ekki flæða í nýja línu
* `flex-wrap: wrap;`, ef það er ekki pláss, flæða í nýja línu (vinstri hægri eða hægri vinstri ef texti lesinn þannig)
* `flex-wrap: wrap-reverse;`, einsog wrap en í öfugri röð

### 2.22.2 Röðun á ás

`justify-content` skilgreinir hvernig flex item er raðað á aðalás:

* `justify-content: flext-start;`, sjálfgefið, raðar við byrjun á ás
* `justify-content: flex-end;`, raðar við enda á ás
* `justify-content: center;`, raðar fyrir miðju áss
* `justify-content: space-between;`, dreifir plássi _milli_ flex itema
* `justify-content: space-around;`, dreifir plássi milli _og utanum_ flex flex item

![](../img/justify-content.svg "Mismunandi röðun með justify-content. Mynd: W3C")

`align-items` skilgreinir staðsetningu _innan línu_ á krossás:

* `align-items: stretch;`, sjálfgefið, jafnar við stærstu línu
* `align-items: flext-start;`, byrjun línu
* `align-items: flext-end;`, enda línu
* `align-items: center;`, miðju línu
* `align-items: baseline;`, jöfnuð við _baseline_

![](../img/align-items.svg "Mismunandi röðun með align-items. Mynd: W3C")

Með `align-self` getur hvert og eitt flex item skilgreint hvernig það hagar sér m.t.t. `align-items`.

`align-content` breytir staðsetningu _lína_ á krossás og hefur því aðeins áhrif ef `flex-wrap` er ekki `no-wrap`.

* `align-content: stretch;`, sjálfgefið, línur teygðar til að taka allt pláss
* `align-content: flext-start;`, raðar við byrjun á ás
* `align-content: flex-end;`, raðar við enda á ás
* `align-content: center;`, raðar fyrir miðju áss
* `align-content: space-between;`, dreifir plássi _milli_ flex itema
* `align-content: space-around;`, dreifir plássi milli _og utanum_ flex flex item

![](../img/align-content.svg "Mismunandi röðun með align-content. Mynd: W3C")

### 2.22.3 Stærðir flex item

Við getum stýrt því hvernig flex item taka pláss innan flexbox með `flex-grow`, `flex-shrink` og `flex-basis`.

`flex-grow` er skilgreint sem rauntala, stærri en 0 og skilgreinir hvernig flex item stækkar, sjálfgefið er `0`.

* Ef öll flex item hafa `flex-grow: 1;` taka þau öll jafnt pláss
* Ef öll hafa `1` en eitt þeirra hefur `2` mun það taka tvisvar sinnum meira pláss (einsog hægt er) en hin flex item fá jafn mikið af plássi sem eftir er
* Ef aðeins eitt flex item hefur `flex-grow` skilgreint mun það taka allt pláss sem önnur flex item þurfa ekki

`flex-shrink` er skilgreint einsog `flex-grow` en stýrir því hvern flex item minnkar, sjálfgefið er `1`.

`flex-basis` skilgreinir hvernig upprunastærð á flex item, áður en plássi er dreift til flex itema, sjálfgefið er `auto`.

Þessi þrjú eigindi ætti alltaf að skilgreina með `flex` eigindi en það stillir óskilgreind gildi rétt m.v. sett gildi. Í flestum tilfellum ætti að vera nóg að setja gildið sem:

* `initial`, sjálfgefið, flex item minnka ef ekki er nóg pláss en stækka ekki umfram `width` og `height` gildi sín
* `auto`, stærð skv. `width` og `height` en stækkar til að fá auka pláss í flexboxi
* `none`, flex item stækka hvorki né minnka
* `<tala>`, tilgreinir hlutfall sem flex item fær af plássi

[Sjá nánar á MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/flex).

Fyrir nánari umfjöllun og góða uppflettingu á virkni flexbox er mælt með [CSS tricks: A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/). Til að hafa smá gaman af því að læra flexbox má prófa [Flexbox Defense](http://www.flexboxdefense.com/) eða [Flexbox Froggy](http://flexboxfroggy.com/)

## 2.23 Skalanleg vefhönnun

> The web’s greatest strength, I believe, is often seen as a limitation, as a defect. It is the nature of the web to be flexible, and it should be our role as designers and developers to embrace this flexibility, and produce pages which, by being flexible, are accessible to all.
-  John Allsopp: [A Dao of Web Design](https://alistapart.com/article/dao) í A List Apart árið 2000

Skalanleg vefhönnun (_responsive web design_) er þegar við sættum okkur við það að vefurinn hvorki er né verður birtur í einni fastri „fullkominni“ stærð sem við hönnum fyrir. Þess vegna er hann margreytilegur einsog tækin sem hann birtist í. Að sætta sig fjölbreytileika vefsins krefst þess að við bæði hönnum og forritum vefina okkar með það í huga.

![Vefurinn er ekki ein föst skjástærð](../img/this-is-not-web.png "Vefurinn er ekki ein föst skjástærð. Mynd: http://bradfrost.com/blog/post/this-is-the-web/")

![Vefurinn er margar skjástærðir á mörgum tækjum](../img/this-is-the-web.png "Vefurinn er margar skjástærðir á mörgum tækjum. Mynd: http://bradfrost.com/blog/post/this-is-the-web/")

![Vefurinn mun aðeins halda áfram að verða flóknari](../img/this-will-bethe-web.png "Vefurinn mun aðeins halda áfram að verða flóknari. Mynd: http://bradfrost.com/blog/post/this-is-the-web/")

Fyrir tíma snjallsíma (fyrir árið 2007) voru vefir langflestir forritaðir fyrir fastar skjástærðir. Þær stærðir sem voru vinsælastar á hverjum tíma voru þær sem flestir notendur höfðu á sínum skjáum. Í fyrstu `640×480` skjáir (640 pixel breiða og 480 pixel háa), síðan `800×600` og að lokum aðallega fyrir `1024×768` skjái. Þegar komið var að `1024×768` upplausn myndaðist samstaða um að nota `960px` hönnun sem algildan grunn, þar sem sú tala deilist þægilega. Þegar snjallsímar komu fyrst á markað og fólk fór að skoða vefi hannaða fyrir `960px` í töluvert minni skjám var lausnin yfirleitt sú að hanna sérstaka „mobile“ vefi sem aðeins voru ætlaðir fyrir minni skjái, þá yfirleitt á `m` lénum, t.d. `m.example.org`.

Árið 2010 skrifaði Ethan Marcotte greinina []„Responsive Web Design“](https://alistapart.com/article/responsive-web-design) í A List Apart þar sem hann kynnir  aðferð til að hanna og byggja vefi sem ekki voru fastir í þessum viðjum heldur _sköluðu_ upp og niður með tækjunum sem þeir birtust í. Þessari grein fylgdi hann svo eftir með [bók](http://abookapart.com/products/responsive-web-design) með sama nafni árið 2011.

![Forsíða RWD bókarinnar](../img/marcotte-responsive-web-design.jpg "Forsíða bókarinn „Responsive Web Design“. Mynd: A List Apart.")

Skalanleg vefhönnun byggir á þremur atriðum, _í mikilvægis röð_:

1. Sveigjanlegu umbroti, byggðu á grind
2. Sveigjanlegum myndum og miðlum
3. CSS media queries

Þegar verið er að hanna eru _grindur_ oft notaðar til þess að hafa undirliggjandi skipulag á því hvernig efnið er sett upp. Í stað þess að raða efni úti um hvippinn og hvappinn er röð og regla til staðar. Grindur eru yfirleitt notaðar fyrir lárétta staðsetningu á vefnum.

![](../img/grid.png "Dæmi um grind í prent hönnun. Mynd: https://commons.wikimedia.org/wiki/File:Grid2aib.svg")

Með því að útfæra skalanlega vefi getum við birt _sama efnið_, með _sama HTML_, á _sömu slóð_ en _aðlögum okkur_ að allskonar tækjum.

Þó svo að á fyrstu árum eftir að skalanleg vefhönnun kom fram á sjónarsviðið hafi verið talað um hana sérstaklega, þá er hún í dag (að mestu leiti!) farin veg _töflulausar hönnunar_. Við gerum einfaldlega ráð fyrir því að vefir í dag skali með tækjunum sem við notum. Að gera það ekki frá grunni skilar sér í slakari vefjum sem mjög erfitt er að laga eftir á.

Annað hugtak sem kom upp á svipuðum tíma og skalanleg vefhönnun er _mobile first_ í [bók sem Luke Wroblewski gaf út hjá A Book Apart](https://abookapart.com/products/mobile-first). Mobile first beitir progressive enhancement á það að byggja skalanlegan vef, við byrjum á því að einblína á upplifun á minni skjám. Með því að byrja með minna pláss neyðumst við til þess að taka ákvarðanir um það hvað sé virkilega mikilvægt og setur efnið í fyrsta sætið.

Önnur leið sem hægt er að taka í stað progressive enhancement er _graceful degradation_, en þá byggjum við upplifun með ákveðna tækni í huga. Við látum síðan virkni brotna tignlarlega niður og gefum síðri upplifun í eldri tækni. Byrjum flókið og lögum okkur að virkni niður á við.

![Graceful Degradation VS. Progressive Enhancement](../img/progressive_enhancement.jpg "Samanburður á því að byggja með graceful degradation eða progressive enhancement í huga.")

### 2.23.1 Sveigjanleg grind

Þegar við vinnum með sveigjanlega grind megum við ekki skilgreina neinar breiddir í nákvæmum stærðum, við verðum að nota hlutfallslegar. Með því að notafæra okkur formúluna `target ÷ context = result` getum við breytt úr nákvæmu gildi í hlutfallsegt fyrir breiddir, margin, padding og letur. T.d. erum við með `1200px` umgjörð og innan hennar erum við með efnissvæði sem á að vera `600px`. Þá getum við sett umgjörðina með `max-width: 1200px;` og efnissvæðið með `600px ÷ 1200px = 0.5` eða `width: 50%;`.

Með sveigjanlegri grind festum við ekki stærð hennar í ákveðnum pixlum. Við skilgreinum fjölda dálka (oft eru 12 dálkar notaðir), bil á milli þeirra (kallað _gutter_) og hámarksstærð svæðis. Síðan reiknum við stærð hvers dálks sem `100% / <fjöldi dálka>`. Innan grindarinn búum við síðan til raðar og dálka sem passa í grindina og staðsetjum efnið okkar í þeim. Fyrir hverja röð viljum við almennt ekki hafa samtölu dálka hærri en fjölda dálka.

Það er ekki krafa að byrja hvern dálk nákvæmlega í fyrsta. Með því að nota `margin` getum við fært dálka innan grindar svo lengi sem gildin eru hlutfallsleg, t.d. byrjað í miðju með `margin-left: 50%;`.

```html
<div class="grid">
  <div class="row">
    <div class="col-6">50% dálkur</div>
    <div class="col-6">50% dálkur</div>
  </div>
</div>
```

```css
.grid {
  max-width: 1200px;
}

.row {
  display: flex;
  margin-left: -10px;
  margin-right: -10px;
}

.col-6 {
  padding-left: 10px;
  padding-right: 10px;

  width: 50%;
}
```

Þegar við skilgreinum grind með bili í CSS setjum við _helming_ bilsins sem `padding` sitthvoru megin á hvern dálk þ.a. þegar þeir liggja hlið við hlið þá verði heilt bil. Til þess að halda samræmi stækkum við röðina í samræmi um eitt bil með því að draga röðina út sitthvoru megin um hálft bil.

![Hreyfimynd sem sýnir mun á relative og static units](../img/02_Relative-Units-vs-Static-Units-1.gif "Hreyfimynd sem sýnir mun á relative og static units. Mynd: http://blog.froont.com/9-basic-principles-of-responsive-web-design/")

![Hreyfimynd sem sýnir mun á max-width og ekki](../img/07_Max-width-vx-No-max-width-1.gif "Hreyfimynd sem sýnir mun á max-width og ekki. Mynd: http://blog.froont.com/9-basic-principles-of-responsive-web-design/")

Grindina notum við fyrir _layout_, skipulag á aðalatriðum á vefnum. Innan grindar falla síðan efnissvæði, hlutir, myndir og miðlar. Fyrir hvern ef þessum hlutum látum við þá fylla upp í 100% af mögulegri breidd foreldris, nota `border-box: box-sizing;` og almennt ekkert `margin` þ.a. þeim sé alveg stjórnað af dálkum grindarinnar. Ef við skilgreinum `margin` er það yfirleitt `margin-bottom` en það gerir það að verkum að hver hlutur ýtir hlutum aðeins frá sér að neðan og við þurfum ekki að hugsa um collapsing margin. Lárétt margin myndu rugla í grindinni.

### 2.23.2 Sveigjanlegar myndir og miðlar

Þegar við erum að útfæra vefi sem eiga að birtast í mörgum mismunandi skjástærðum getum við ekki sett inn myndir og miðla sem eru af fastri stærð. Mynd sem er `1200px` breið og á að birtast í dálk sem búið er að skala niður í `600px` mun ekki birtast snyrtilega nema við gerum ráðstafanir. Við getum fest breidd mynda og miðla við breidd foreldris og látið skalast og þurfum þá aðeins að skilgreina `max-width: 100%;` en þá mun efnið alltaf fylla upp í breiddina. Við getum átt við hvernig efnið birtist með því að skera (crop) myndina til, `object-fit` getur hjálpað okkur við að skilgreina hvernig myndin er skorin eða sköluð og þá stundum í samhengi við `height` og `overflow: hidden;`.

```css
img {
  /*
  mynd skalast þ.a. hún fylli alltaf upp í
  lárétt pláss í foreldri
  */
  max-width: 100%;
}
```

Ef við viljum viðhalda stærðarhlutföllum nákvæmlega getum við notað eftirfarandi „trikk“ sem nýtir sér gervi-element, barn sem fyllir upp í foreldri sitt og það að `padding-top` með hlutfallslegri tölu reiknast útfrá `width`:

```html
<div class="box">
  <div class="content">16:10 efni</div>
</div>
```

```css
.box {
  position: relative;
  width: 100%; /* fyllir upp í foreldri sitt, t.d. dálk */
}

.box::before {
  content: '';
  display: block;
  padding-top: 62.5% /* fyrir 16:10 setjum við 10/16*100=62.5% */
}

.content {
  /* fyllir upp í foreldri sitt */
  position: absolute;
  top: 0; right: 0; bottom: 0; left: 0;

  background-color: red;
}
```

[Embed Responsively](http://embedresponsively.com/) getur útbúið kóða fyrir okkur fyrir vinsælar þjónustur. Nánar má lesa um hvernig þetta virkar í greininni [Height equals width with pure CSS](http://www.mademyday.de/css-height-equals-width-with-pure-css.html).

### 2.23.3 Media queries

Með _media queries_ getum við skilgreint „brotpunkta“ í hönnun þar sem við breytum á einhvern hátt hvernig layout á vef hagar sér. Við miðum við heildar breidd á viewport og getum skilgreint CSS sem keyra upp að ákveðinni breidd, frá ákveðinni breidd, blandað þessu saman til að skilgreina á bili, skilgreint eins fyrir hæð og, fleira. Sjá nánar í [MDN: Using media queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries).

Við getum (og ættum) að beita progressive enhancement þegar við notum media queries. Það þýðir að grunnstílar ættu að skilgreina hvernig hlutur lítur út þegar hann fyllir alveg út í pláss sitt – er í minnstri upplausn, t.d. í snjallsíma. Eftir því sem hlutur fær meira pláss skilgreinum við media queries sem breyta hegðun með auknu plássi.

```css
/* almennt er section 100% breitt */
section {
  width: 100%;
}

/* frá 800px breiðum viewport er section 50% breitt */
@media (min-width: 800px) {
  section {
    width: 50%;
  }
}
```

Fyrir grindina verður það þó skrítið ef við byrjum að breyta dálka skilgreiningum með media queries. T.d. ef við höfum `.col-6` sem á að taka 6 dálka af 12 en allt í einu frá og með einhverri breidd verða það 4 af 12 eða 12 af 12. Lausn á þessu eru að útbúa skilgreiningar sem taka fram fyrir almennu skilgreininguna og nýta „flæðið“ og media queries til að fá mismunandi gildi eftir upplausn, t.d. `.col-6 .col-sm-12`, almennt taka 6 af 12 dálkum en í `sm` (small) upplausn, taka 12 af 12.

```html
<div class="grid">
  <div class="row">
    <div class="col col-6 col-sm-12">
      <div class="box">50% dálkur almennt, 100% í minni upplausn</div>
    </div>
  </div>
</div>
```

```css
.col-6 {
  width: 50%;
}

@media (max-width: 599px) {
  .col-sm-12 {
    width: 100%;
  }
}
```

### 2.23.4 Skalanlegir vefir og upplausn

Mismunandi tæki sem birta vefina okkar hafa mismunandi upplausn, þau koma mismörgum pixelum fyrir á skjánum. _Physical resolution_ segir til um raun upplausn á skjá, t.d. `960×640` en _logical resolution_ segir til um raun **stærð** skjás, t.d. `480×320`. Hlutfallið þarna á milli er _device pixel ratio_, t.d. `2x`. [_Pixel density_](https://en.wikipedia.org/wiki/Pixel_density) segir til um fjölda pixela á tommu eða cm. _Retina display_ er markaðshugtak frá Apple þar sem pixel density er um 300 ppi og við horfum á skjáinn í um 25 cm fjarlægð — augað greinir ekki pixela.

Við getum leiðbeint vöfrum um hvernig við viljum að síða birtist með `<meta name="viewport">` en í `content` attribute getum við sett einhver af eftirfarandi gildum:

* `width` setur breidd viewports: tala eða _device-width_ sem lætur viewport vera jafnt _logical resolution_ ekki _physical resolution_
* `initial-scale`, upphafs þysjun (zoom) á síðu, yfirleitt `1`
* `minimum-scale`, hversu lítil síða má verða — hve langt má þysja út
* `maximum-scale`, hversu stór síða má verða — hve langt má þysja inn
* `user-scalable`, má notandi þysja? Þetta viljum við alltaf leyfa

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```

Ef við skilgreinum ekki `width=device-width` í `<meta name="viewport">` og notum media queries mun vefurinn okkar ekki birtast einsog við höldum í tækjum með hærri raunupplausn.

### 2.23.5 Allir saman nú!

Með því að nýta þessi þrjú hugtök:

1. Sveigjanlegu umbroti, byggðu á grind
2. Sveigjanlegum myndum og miðlum
3. CSS media queries

saman fáum við síðu sem bregst við umhverfi sínu og skalast alveg frá lítilli upplausn síma upp í háa upplausn á risa-sjónvarpi. Einsog marg annað er þetta einföld hugmynd sem fljótt verður flókin í útfærslu. Við getum nýtt okkur tól í vöfrum til að prófa lausnirnar okkar, en til að vita nákvæmlega hvernig þetta hagar sér þarf að prófa á tækjunum sjálfum. Það getur síðan í sjálfu sér orðið erfitt þar sem þau eru mörg og engin tvö nákvæmleg eins.

## 2.24 CSS í stærri verkefnum

Þegar við byrjum að skrifa CSS er það einfalt og við höfum yfirsýn yfir hvað gerir hvað. Línurnar þurfa ekki að vera orðnar ýkja margar áður en yfirsýnin fer að dala og við förum að verða hrædd um að skemma eitthvað með breytingunum okkar. Sérstaklega útaf því að CSS er hannað þ.a. allir hlutir „flæði“ yfir alla — allt er almennt og getur haft áhrif á allt. Nokkrar leiðir hafa komið fram í gegnum árin til að halda í stjórnina og yfirsýnina.

### 2.24.1 „Append only stylesheets“

Ef við pössum okkur ekki mun CSS í verkefnum okkar hægt og rólega falla í óreiðu. Viðbætur sem verða til eftir upprunaleg skrif verða erfiðar þar sem ekki er augljóst hvernig hlutirnir virka, mismunandi forritarar skrifa á mismunandi vegu, blanda af selectorum gerir hluti óljósa o.fl. Hræðsla við að brjóta útlit á einhverri síðu á vefnum gerir það að verkum að tiltekt verður erfið og við endum með „append only stylesheets“, ný virkni er skrifuð sérstaklega og bætt við aftast.

```css
/* einhverjar reglur eru skilgreindar beint á type */
button { }

/* önnur tegund notar class selector */
.button { }

/* enn önnur type og class */
button.button { }

/* eða önnur, óljós nöfn */
.button2 { }
```

### 2.24.2 CSS viðmiðunarreglur

Í stórum verkefnum þar sem við erum að vinna ein eða í teymi er mikilvægt að eyða tíma í það að búa til viðmiðunarreglur (guidelines) um það hvernig við skrifum CSS. Þær geta varðað marga hluti

* Hvernig nefnum við og skiptum upp hlutum?
* Hvernig skrifum við selectora?
* Hvernig högum við layout? Notum við grind?
* o.s.fr.

Nokkrar aðferðir hafa verið búnar til og getum við tileinkað þær, t.d.:

* [SMACSS](https://smacss.com/) – _Scalable and Modular Architecture for CSS_
* [OOCSS](https://www.smashingmagazine.com/2011/12/an-introduction-to-object-oriented-css-oocss/) – _Object oriented CSS_
* [SUIT CSS](https://suitcss.github.io/) – _Style tools for UI components_
* [BEM](http://getbem.com/) – _Block Element Modifier_

Allar af þessum aðferðum koma með viðmiðunarreglum en sumar koma einnig með tæki og tól sem hjálpa enn frekar til.

### 2.24.3 BEM

BEM, _Block Element Modifier_, er tiltölulega einföld aðferð þar sem hún einblínir á það _hvernig_ við skrifum selectora. Við notum aðeins class selector, enga type eða id selectors. Einnig leyfum við okkur að aðskilja merkingarfræðina enn frekar frá útliti, þar sem við getum sett `class` á hvaða element sem er til þess að fá viðeigandi útlit á það.

* _Block_ - hæsta stig á _component_, foreldrið, t.d. `.button`
* _Element_ - börn undir _block_, t.d. `.button__price`
* _Modifier_ - breytir block án þess að hafa áhrif almennt, t.d. `.button--wide`

```css
.block { }
.block--modifier { }
.block__child { }
.block__child--modifier { }
```

Með BEM skrifum við flata selectora, við erum ekki að hreiðra undir öðrum. Í HTML verðum við að tryggja að við hreiðrum rétt.

```css
/* Ekki svona */
.block .block__child { }

/* heldur svona */
.block__child { }

/* en modifer getur haft áhrif á child */
.block--modifier .block__child { }
```

[CSS Tricks: BEM 101](https://css-tricks.com/bem-101/) fer nánar út í hvað BEM er.

### 2.24.4 Style Guides & Pattern Libraries

Önnur góð leið til að viðhalda skipulagi er að útbúa _style guide_ eða _pattern library_. Þau safna saman hlutum sem mynda vefinn okkar, ekki í hönnunarskjölum heldur sem dæmi í kóða. Með þessu höfum við einn stað til að fá og sjá yfirlit yfir það úr hverju vefurinn okkar er byggður. Hönnun verður samræmdari, við vitum hvernig hlutir munu líta út og ef við smíðum eitthvað nýtt bætum við því við svo aðrir sjái. [styleguides.io](http://styleguides.io/) er vefur sem heldur utan um mörg mismunandi styleguide.

![](../img/mailchimp_type.png "Skjáskot úr styleguide Mailchimp sem sýnir fyrirsagnir. Mynd: http://ux.mailchimp.com/patterns")

![](../img/mailchimp_buttons.png "Skjáskot úr styleguide Mailchimp sem sýnir takka. Mynd: http://ux.mailchimp.com/patterns")

### 2.24.5 Atomic Design

_Atomic design_ er leið, þróuð af Brad Frost, sem skilgreinir hvernig við getum búið til kerfi utan um vefina okkar. Í grunninn skiptist hún í að skilgreina:

* Atóm – grunn element, t.d. input, litir
* Sameind – sameinuð atóm, t.d. form
* Lífveru – hópur af sameindum, t.d. leitar form, navigation
* Sniðmát – hópa saman lífverum og mynda síður
* Síðu – ákveðin tilvik af sniðmátum með _alvöru efni_ sem notendur sjá

![](../img/atomic-design.png "Yfirlitsmynd yfir atomic design. Mynd: http://bradfrost.com/blog/post/atomic-web-design/")

Hægt er að lesa nánar um atomic design í [Atomic Design](http://atomicdesign.bradfrost.com/) bók Brad Frost sem hægt er að nálgást ókeypis á vefnum.

## 2.25 CSS Grid

## 2.26 Kvikun

Kvikun (animation) er þegar við látum eitthvað hreyfast eftir ákveðnum reglum. Í CSS er hægt að gera það með `transition` og `animation` eigindunum. Með því að nota hreyfingar getum við gert viðmót eðlilegra, vinalegra og skemmtilegra. Viðmót geta orðið fágaðari, þar sem við fjarlægjum „grófleikan“ sem getur orðið ef við breytum einhverju. Of mikið af hreyfingum er þó ekki eitthvað sem við viljum, það þarf ekki _allt_ að hreyfast _alltaf_.

[Material Design - Motion](https://material.google.com/motion/material-motion.html) er góður inngangur að _motion design_, hönnun með hreyfingar í huga.

### 2.26.1 Umskipti

Með umskiptum (transition) látum við eitt gildi breytast í annað á skilgreindum tíma. Breytingin gerist ekki strax, það er einhver brúun á milli upphafs og endagildis. Við skilgreinum hvaða eigindi eigi að breyta, á hve löngum tíma og með hvaða hröðun. Vafrinn sér síðan um að brúa gildið m.v. það sem við viljum.

Umskipti virka þannig að vafri fylgist með gildi og ef við skilgreinum að það breytist (t.d. ef við setjum nýtt gildi með `:hover`) þá er gildinu ekki breytt samstundis.

`transition` er shorthand fyrir:

* `transition-property`, skilgreinir hvaða eigindi eigi að umskipta
* `transition-duration`, skilgreinir hve lengi umskipti eigi að taka
* `transition-timing-function`, skilgreinir hröðunar fall umskipta
* `transition-delay`, skilgreinir hve lengi skuli bíða með umskipti

```
/* transition: <property> <duration> <timing-function> <delay> */
transition: color 250ms linear 0;
```

Hægt er að skilgreina fleiri en eitt umskipti með því að skipta á kommu, `,`:

```css
transition: color 250ms, background-color 250ms;
```

Með `transition-property` skilgreinum við með hvaða eigindi við fylgjumst. Það er leyfilegt að setja `all` sem gildi en þá er fylgst með breytingum _á öllum_ eigindum og getur það valdið óþarfa hægagangi. Við viljum vera nákvæm í því hvað á að breytast.

Tíma er hægt að skilgreina í millisekúndum (`250ms`) eða sekúndum (`1.25s`).

Með því að nota `transition` getum við komið í veg fyrir groddaralegar breytingar t.d. þegar við breytum gildum á `:hover`:

```css
a {
  background-color: #000;
  color: #fff;

  /*
  í staðinn fyrir að skipta beint úr svörtu í hvítt gerum
  við það á 250ms svo það verður ekkert „blikk“
  */
  transition: color 250ms, background-color 250ms;
}

a:hover {
  background-color: #fff;
  color: #000;
}
```

### 2.26.2 Hröðun

Hröðunarfall er skilgreint með _rúmfræðilegri bezier kúrvu_ (cubic bezier curve) eða lykilorði (sem er tengt við ákveðna bezier kúrvu).

![](../img/cubic-bezier.png "Dæmi um bezier kúrvu. Mynd: https://developer.mozilla.org/en-US/docs/Web/CSS/single-transition-timing-function")

Bezier kúrvur eru föll sem við getum notað til að skilgreina hvernig gildi breytist yfir tíma, hver hröðun þess er. Ef við höfum línulega hröðun fer gildið frá upphafsgildi til lokagildis með nákvæmlega sama hlutfalli á hverja tímaeiningu. `cubic-bezier(x1, y1, x2, y2)` er fall í CSS sem leyfir okkur að skilgreina nákvæmlega hvernig kúrvan hagar sér en við notum yfirleitt lykilorð sem skilgreina mikið notaðar kúrvur.

* `linear`, hröðun er línuleg
* `ease`, sjálfgefið gildi fyrir þau eigindi sem nota hröðun, mikil hröðun í byrjun, hægir síðan á sér og kemur rólega í mark
* `ease-in`, byrjar hægt en eykur hröðun eftir því sem endi nálgast
* `ease-in-out`, byrjar hægt, eykur hraða en hægir aftur á sér þegar endi nálgast
* `ease-out`, byrjar hratt en hægir á sér þegar endi nálgast

![](../img/cubic-bezier-linear.png "Línuleg hröðun með linear lykilorði. Mynd: https://developer.mozilla.org/en-US/docs/Web/CSS/single-transition-timing-function")

![](../img/cubic-bezier-ease-in-out.png "Hröðun með ease-in-out lykilorði. Mynd: https://developer.mozilla.org/en-US/docs/Web/CSS/single-transition-timing-function")

Nánar má lesa um [hörðunarföll í CSS á MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/single-transition-timing-function).

### 2.26.3 Animation

Með `animation` eigindinu getum við útbúið flóknari hreyfingar án þess að nota JavaScript. Við skilgreinum _keyframes_ fyrir hreyfinguna með `@keyframes` at-reglunni. Hreiðraðar skipanir innan `@keyframes` hafa ekki selector heldur prósentugildi eða, lykilorðin `from` sem er jafngilt `0%` eða `to` sem er jafngilt `100%`. Gildin segja til um hvernig hreyfing lítur út á viðeigandi stað og mun vafri brúa á milli m.v. gefinn tíma og hröðun.

```css
@keyframes fade {
  /* þegar hreyfing er í 0% er opacity: 0 */
  from { opacity: 1; }

  /* þegar hreyfing er í 50% er opacity: 0.4 */
  50% { opacity: 0.4; }

  /* þegar hreyfing er í 100% er opacity: 1 */
  to { opacity: 0; }
}
```

Við stýrum síðan hvernig hreyfing hagar sér með `animation` sem er shorthand fyrir:

* `animation-name`, nafnið á hreyfingu skilgreindu með `@keyframes`
* `animation-duration`, hversu langan tíma hreyfing eigi að taka
* `animation-timing-function`, hröðunarfall
* `animation-delay`, hversu lengi eigi að bíða með að byrja hreyfingu
* `animation-iteration-count`, hversu oft á að keyra hreyfingu, tala sem sjálfgefið er `1`, getur líka tekið gildið `infinite`
* `animation-direction`, í hvaða átt á að keyra hreyfingu
  - `normal`, sjálfgefið, keyrð _áfram_ og þegar hún klárast byrjað aftur frá byrjun
  - `reverse`, keyrð _afturábak_ og byrjað á enda þegar hún klárast
  - `alternate`, keyrð áfram og afturábak til skiptis
  - `alternate-reverse`, keyrð afturábak og áfram til skiptis
* `animtaion-fill-mode`, hvernig á að tækla eigindi sem aðeins eru sett í hreyfingu eftir og áður en hún keyrir? Sjá nánar á [MDN: animation-fill-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode)
* `animation-play-state`, í hvaða stöðu er hreyfing, sjálfgefið `running` en getur líka verið `paused`

```
/* animation: duration | timing-function | delay |  iteration-count | direction | fill-mode | play-state | name */
animation: 2s ease 0 infinite alternate both running fade;

/* animation: duration | name */
animation: 3s fade;
```

### 2.26.4 Transform

Með `transform` eigindinu getum við gert breytingar á tvívíðu og þrívíðu rúmi hluta með því að nota `translate`, `rotate`, `skew` og `scale`. Lang flestar af þessum aðgerðum verða fluttar af vafra frá _CPU_ yfir á _GPU_ (graphics processing unit, sérstakur kubbur í tölvu sérhannaður til að vinna með grafík) og eru þessar aðgerir því **miklu** hagkvæmari en að reikna út gildi og teikna allt útlit vefs aftur ef við myndum t.d. nota `position`.

Ef við viljum færa hlut notum við `transform: translate(x, y)` til að færa á x og y-ás. Getum einnig gert í þrívíðu rúmi með `transform: translate3d(x, y, z)`.

Ef við viljum stækka eða minnka hlut notum við `transform: scale(ratio);` þar sem `ratio` er hlutfall, `1.0` og hlutur er í venjulegri stærð (m.v. teiknað útlit), `0.5` og hann er helmingi minni, `2.0` og hann er tvisvarsinnum stærri.

Sjá nánar um notkun á `transform` á [MDN: Using CSS transforms](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms/Using_CSS_transforms).

### 2.26.5 Jank

Þegar við erum að vinna með hreyfingar viljum við halda þeim mjúkum og fínum, án þess að þær haltri eða líti skringilega út. Galdratalan í því samhengi eru 60fps eða 60 rammar á sekúndu. Það þýðir að hver vafrinn (eða það sem er að birta hreyfingu) hefur 16,67 millisekúndu per ramma til að gera alla þá útreikninga sem þarf til að láta næsta ramma birtast rétt. Ef við erum að gera of mikið á þessum tíma, t.d. hreyfa of marga hluti eða á óhagkvæman máta, þá förum við að taka eftir _jank_, hlutir hreyfast óeðlilega.

![](https://www.youtube.com/embed/-62uPWUxgcg "Dæmi um jank í vefviðmóti.")

TIl að komast hjá jank þegar við búum til hreyfingar er ein einföld regla sem kemur okkur vel áleiðis:

**Aðeins breyta `opacity` og `transform` þegar við hreyfum hluti**

Einnig getum við notað `will-change` eigindið sem lætur vafra vita að við munum breyta ákveðnum eigindi og er þá hægt að gera viðeigandi ráðstafanir.

Listin að gera vefi sem eru hraðir og nýta hagkvæmar leiðir er mikil list, hægt er að læra meira á [Jank Free](http://jankfree.org/).

## 2.27 Tæki & tól

Þar sem CSS hefur ekki föll og flóknari aðgerðir er búið að útbúa ýmis tól sem hjálpa okkur við að skrifa skipulegra CSS með leiðum til að draga úr endurtekningum, t.d.:

* Breytur, getum skilgreint fyrir liti, stærðir o.fl.
  - CSS breytur eru þó orðnar nokkuð vel studdar í seinni tíð
* _mixins_, leiðir til að endurýta reglublokkir, virka svipað og föll
* _nesting_, skrifum reglublokkir innan reglublokka og nýtum selector að ofan

Dæmi um mál sem útfæra þetta eru:

* [LESS](http://lesscss.org/)
* [Stylus](http://stylus-lang.com/), _Expressive, dynamic, robust css_
* [Sass](http://sass-lang.com/), _Syntactically Awesome Style Sheets_

Flest af þessum tólum virka sem _superset_ af CSS, sem þýðir að „venjulegt“ CSS virkar en ef við bætum við það virkni úr málinu bæta þau við virkni. Við þurfum að sækja okkur _þýðanda_ fyrir málið sem þá þýðir fyrir okkur úr því í „venjulegt“ CSS.

### 2.27.1 Sass

Sass er töluvert mikið notað og hefur þýðendur í mörgum umhverfum. Eldri útgáfa af málinu notaði `.sass` endingu á skjölum en nýrri („sassy CSS“) notar `.scss`.

Sass útfærir breytur með `$` fyrir framan eigindi og leyfir okkur að nota á öðrum stöðum með virkjum og hjálparföllum:

```sass
// svona komment virka
$blue: #3bbfce;
$margin: 16px;

.box {
  margin: $margin / 2; // eigum við breytu með virkja
  background-color: $blue * 2; // líka fyrir liti!
}
```

sem er þýtt yfir í:

```css
.box {
  margin: 8px;
  background-color: #76ffff;
}
```

Við getum líka notað _mixin_ og hreiðraðar reglur sem geta nýst okkur t.d. ef við erum að skrifa BEM:

```sass
@mixin rounded($color: transparent) {
  border: 1px solid $color;
  border-radius: 5px;
}

.box {
  &__header {
    @include rounded;
  }

  &__content {
    @include rounded(#000);
  }
}
```

sem er þýtt yfir í:

```css
.box__header {
  border: 1px solid transparent;
  border-radius: 5px;
}
.box__content {
  border: 1px solid #000;
  border-radius: 5px;
}
```

_media queries_ geta verið settar undir selector sem getur hjálpað töluvert við að hópa saman hvernig hlutur hegðar sér í mismunandi upplausnum:

```scss
.foo {
  width: 100%;

  @media (min-width: 800px) {
    width: 50%;
  }
}
```

Við getum nýtt okkur mixins og hreiðrun til að einfalda grid virkni og gera læsilegri:

```sass
$gutter: 20px;

.row {
  display: flex;
  flex-wrap: wrap;
  margin-right: -($gutter / 2);
  margin-left: -($gutter / 2);
}

// mixin sem reiknar nákvæmar prósentur útfrá dálkum
@mixin columns($col: 1) {
  // margföldum með "1%" til að breyta gildi í prósentu gildi
  width: ($col / 12 * 100) * 1%;
}

.col {
  padding-right: $gutter / 2;
  padding-left: $gutter / 2;

  &-12 {
    @include columns(12);
  }

  &-sm {
    // viljum að col-sm-* sé notað alveg upp að 800px, ekki í 800px samt
    @media (max-width: 799px) {
      &-12 {
        @include columns(12);
      }
    }
  }

  // o.s.fr...
}
```

Með Sass og `@import` at-regluna til þess að skipuleggja skránar okkar betur, í grunn skránni okkar (t.d. `styles.scss`) setjum við almennar skilgreiningar og sækjum síðar aðrar skrár. Þannig getum við ennfrekar skipulagt CSS virknina okkar og komið í veg fyrir stórar, flóknar skrár:

```scss
$max-width: 1200px;
$gutter: 20px;

main {
  max-width: $max-width;
  margin: 0 auto;
}

@import "scss/grid";
// o.s.fr.
```

Hægt er lesa nánar um virkni sem Sass bíður upp á í [skjölun](http://sass-lang.com/documentation/file.SASS_REFERENCE.html) og prófa sig áfram með [_Sassmeister_](https://www.sassmeister.com/) sem þýðir Sass í vafra.

Þá er næsta spurning, hvernig getum við notað svona sniðugt tól í okkar verkefnum?

### 2.27.2 npm

npm er _pakkastjóri_ (package manager) fyrir JavaScript en leyfir okkur líka að setja upp og nota allskonar tól sem byggð eru með JavaScript.

Pakkastjóri sér um að sjálfvirknivæða það að setja upp, stilla og fjarlægja hugbúnað. Í staðinn fyrir að þurfa að sækja einhvern hugbúnað, finna hvert við sóttum hann, keyra eitthvað uppsetningarforrit og síðan keyra forritið, þá keyrum við eina skipun og höfum aðgang að forriti.

npm er sett upp með _node.js_ og þurfum við því að setja það upp, en hægt er að nálgast [nýjustu útgáfu af node.js á vef þess](https://nodejs.org/).

Eftir að hafa sett upp node.js getum við opnað terminal og staðfest að við höfum aðgang að báðu:

```bash
> node -v
v8.5.0 (eða sú útgáfa sem við sóttum)
> npm -v
5.3.0
```

Með node.js og npm uppsett getum við sótt okkur tæki og tól til þess að auðvelda líf okkar í vefforritun. Það eru tvær aðferðir til þess:

* Setja tól upp almennt, eða
* Setja upp tól í verkefninu okkar

### 2.27.3 Almenn tól

Með því að setja upp almennt tól getum við notað það hvar sem er gegnum terminal.

[`browser-sync`](https://www.browsersync.io/) er dæmi um svona tól, en það leyfir okkur að keyra lítinn vefþjón á okkar eigin vél og sjálfkrafa endurhlaða síðu þegar við gerum breytingar sem getur sparað okkur ófáa smellina.

Byrjum á því að setja upp `browser-sync` almennt með npm með því að nota `-g` flaggið sem stendur fyrir „global“.

```bash
> npm install -g browser-sync
...
added 412 packages in 37.537s # eða eitthvað álíka
```

Ef við förum nú í möppu þar sem við höfum `index.html` og `styles.css` skjal getum við kveikt á `browser-sync` vefþjóninum með:

```bash
> cd /slóð/á/verkefni
> browser-sync start --server --files index.html styles.css
[Browsersync] Access URLs:
 ----------------------------------------
       Local: http://localhost:3000
    External: http://192.168.1.1:3000
 ----------------------------------------
          UI: http://localhost:3001
 UI External: http://192.168.1.1:3001
 ----------------------------------------
[Browsersync] Serving files from: ./
[Browsersync] Watching files...
```

en þá fylgist `browser-sync` með `index.html` og `styles.css` og sjálfkrafa endurhleður síðuna. Galdrar! (samt bara forritun).

En núna erum við búin að setja upp þetta tól og getum notað fyrir einhver verkefni, en hvað ef við viljum leyfa öðrum í teyminu okkar að njóta þess sama?

### 2.27.4 Tól í verkefnum

Með því að innifela tólin sem við notum við þróun á verkefni í verkefninu sjálfu erum við nákvæm um hver _dependency_ okkar eru. Ef aðrir (þar með talið við sjálf eftir einhvern) koma að verkefninu viljum við að allt sé skýrt, hvaða tól sé verið að nota og hvernig. npm getur hjálpað okkur með þetta.

Ef við förum í möppuna þar sem verkefnið okkar er geymt og keyrum `npm init` skipunina spyr npm okkur um uplýsingar varðandi verkefnið okkar. Þær eru síðan geymdar í `package.json` skrá. Við getum síðan bætt sérstaklega við _dependency_ á ákveðin tól, t.d. `browser-sync` með því að nota `npm install <pakki> --save-dev` en það segir npm að vista vísun í `browser-sync` í  `package.json` þar sem `browser-sync` er _development dependency_. Ef við tilgreinum `--save` erum við að segja að pakkinn sé keyrslu _dependency_, þ.e.a.s. til að verkefnið keyri þarf þessi pakki að vera til.

```bash
> cd /slóð/á/verkefni
> npm init
..svara spurningum
> npm install browser-sync --save-dev
...
added 412 packages in 37.537s # eða eitthvað álíka
```

og lítur `package.json` þá einhvern vegin svona út:

```json
{
  "name": "prufa",
  "version": "0.0.1",
  "description": "Prufupakki Óla",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Óli",
  "license": "ISC",
  "devDependencies": {
    "browser-sync": "^2.18.13"
  }
}
```

en hún er geymd á `json` formi sem er gagnaform sem á rætur sínar að rekja til JavaScript. Að auki `package.json` verður til `package-lock.json` sem geymir nákvæmar útgáfur þeirra forrita sem við treystum á, því þau sjálf hafa sín eigin dependency. `./node_modules` er síðan mappa sem verður til samhliða þessum skrám og geymir hún forritakóða fyrir alla pakka sem við höfum sett upp. Þessi mappa er útbúin útfrá `package.json` og `package-lock.json` og þarf því ekki að geyma hana eða senda með sérstaklega. Við einfaldlega keyrum `npm install` og npm sér um að sækja allt sem sækja þarf.

En hvernig keyrum við þá `browser-sync`?

### 2.27.5 npm scripts

npm býður upp á leið til þess að skilgreina _skriptur_ sem við getum keyrt með `npm run <nafn-á-skriptu>`. Við skilgreinum þessar skriptur undir `"scripts"` hlutanum í `package.json`, ef við bætum við skriptu til að keyra `browser-sync` við dæmið að ofan fáum við:

```json
"scripts": {
  "browser-sync": "browser-sync start --server --files index.html styles.css"
},
```

sérstaklega þarf að passa upp á að hafa `,` á eftir hverri skriptu ef önnur fylgir og enga kommu í lokin.

Við getum þá keyrt `browser-sync` í verkefninu okkar með:

```bash
> npm run browser-sync
```

og fengið sömu virkni og áður en núna tekur verkefnið okkar skýrt fram að það noti `browser-sync`.

### 2.27.6 node-sass

`node-sass` er þýðandi fyrir Sass skrifaður fyrir node.js sem við getum sótt með npm.

```bash
> npm install --save node-sass
```

`node-sass` kemur með CLI forriti sem við getum keyrt og gefið slóð á `.scss` skrár og nafn á `.css` skrá og er þá sass þýtt yfir í CSS skrá. `-w` flag lætur forritið vakta skránna okkar og þýða hana aftur ef `.scss` skrár breytast.

```json
"scripts": {
  "browser-sync": "browser-sync start --server --files index.html styles.css",
  "sass": "node-sass styles.scss styles.css -w"
},
```

```bash
> npm run sass
=> changed: /slóð/á/verkefni/styles.scss
Rendering Complete, saving .css file...
Wrote CSS to /slóð/á/verkefni/styles.css
```

Núna lendum við í því að hafa tvö tól sem við viljum keyra á sama tíma, við því eru tvær lausnir:

1. Keyra tvö terminal sem keyra sitthvort command, það getur virkað en verið heldur leiðinlegt í uppsetningu
2. Finna _annað_ tól sem leyfir okkur að keyra bæði í einu!

[`npm-run-all`](https://github.com/mysticatea/npm-run-all) er einn af mörgum pökkum sem leyfir okkur að keyra margar skipanir í einu. Ef við setjum hann upp og keyrum:

```bash
> npm install --save-dev npm-run-all
```

og bætum við skriptum

```json
"scripts": {
  "browser-sync": "browser-sync start --server --files index.html styles.css",
  "sass": "node-sass styles.scss styles.css -w",
  "dev": "npm-run-all --parallel sass browser-sync"
},
```

og þá getum við keyrt bæði tólin okkar í einu með:

```bash
> npm run dev
```

Það er venja að hafa skriptu sem heitir eitthvað í áttina að `dev` (fyrir development) til að keyra þróunartólin í gang.

### 2.27.7 stylelint

Seinasta CSS þróunartólið sem við setjum upp er [`stylelint`](https://github.com/stylelint/stylelint) en einsog nafnið gefur til kynna er það _linter_ fyrir CSS (og fleiri mál, t.d. Sass). Því fylgja margar reglur sem hægt er að sér sníða fyrir hvert og eitt verkefni, eða fá ákveðnar _best practices_ reglur með, t.d. [`stylelint-config-primer`](https://github.com/primer/stylelint-config-primer) sem inniheldur grunnreglur og styður sass.

```bash
> npm install --save-dev stylelint
...
> npm install --save-dev stylelint-config-primer
```

Til þess að kveikja á `stylelint-config-primer` reglunum þurfum við að búa til `.stylelintrc` skrá (skrár sem byrja á `.` eru oft notaðar til að geyma stillingar, en þær geta líka valdið vandræðum þar sem mörg stýrikerfi fela þær) sem inniheldur:

```json
{
  "extends": "stylelint-config-primer"
}
```

og bætum við skriptu sem keyrir tólið:

```json
"scripts": {
  "browser-sync": "browser-sync start --server --files index.html styles.css",
  "sass": "node-sass styles.scss styles.css -w",
  "dev": "npm-run-all --parallel sass browser-sync",
  "lint": "stylelint styles.scss --syntax scss"
},
```

Ef við núna skrifum sass/css sem ekki er talið gott samkvæmt reglunum sem við höfum valið okkur:

```scss
h1 {
  color: red;
}
```

og keyrum lint til að athuga (`-s` stendur fyrir silent, en þá sleppir npm að sýna upplýsingar um keyrslu)

```bash
> npm run lint -s
styles.scss
1:1   ✖  Expected "h1" to have no more than 0 type  selector-max-type selectors
3:10  ✖  Unexpected named color "red"               color-named
```

Þegar við vinnum í verkefnum í teymi, þar sem ákveðnar reglur um kóðastíl hafa verið skilgreindar förum við eftir þeim til að halda samræmi. Við erum e.t.v. ekki alltaf sammála reglunum, en við treystum því að það séu góðar ástæður þar að baki, eða ræðum við teymið okkar um að breyta þeim.

Allar reglur sem hægt er að stilla í Stylelint [má nálgast á vefnum](https://stylelint.io/user-guide/rules/). Ef við viljum breyta því hvernig regla virkar getum við stillt hana sérstaklega í `.stylelintrc`, t.d. [banna tómar athugasemdir](https://stylelint.io/user-guide/rules/comment-no-empty/):

```json
{
  "extends": "stylelint-config-primer",
  "rules": {
    "comment-no-empty": true
  }
}
```

Það geta þó komið upp aðstæður þar sem við viljandi brjótum almenna reglu fyrir sértækt tilvik. T.d. viljum við setja letur á `html` en Stylelint vill ekki að við notum type-selector. Við getum þá slökkt á athugun á þeirri línu með `/* stylelint-disable-line */` (einnig [hægt að slökkva á fleiri vegu](https://stylelint.io/user-guide/configuration/#turning-rules-off-from-within-your-css))

## 2.28 Hönnun

Að lokum er vert að tæpa aðeins á því sem ber að hafa í huga þegar _við förum að hanna okkar eigið útlit_. Forritarar eiga það margir til að hunsa skipulag og framsetningu á efni og einfaldlega koma allri virkni á skjáinn (stundum kölluð _forritaraútlit_)

![](../img/okcancel20031010.gif "Ýkt dæmi um „forritaraútlit“. Mynd: http://okcancel.com/comic/4.html")

### 2.28.1 Röðun og jöfnun

Röðun og jöfnun (alignment) á efni skiptir máli. Við ættum að leggja okkur fram við að setja hluti skipulega upp með reglu. Notkun á grind getur hjálpað til hér þar sem hún skilgreinir grunn til að vinna á. Eins ættu bil á milli efnis ekki að vera handahófskennd heldur fylgja reglu.

Í byrjun ættum við að setja okkur reglu um hvernig hlutum er raðað og þeir jafnaðir. Texti ætti að vera eins jafnaður (til vinstri, hægri eða jafnaður). Bil stöðluð og notuð á milli (margin) og innan (padding) hluta. T.d. ef við gefum okkur grunnbil upp á `20px` getum við notað þá tölu og margfeldi af henni til að mynda bil, t.d. `3 * 20px` sem gott bil á milli tveggja svæði.

![](../img/alignment.png "Mynd af handahófskenndri staðsetningu með handahófskenndum bilum VS jöfnum bilum.")

Þegar við erum að skipuleggja efni er mikilvægt að huga að hópun. Hlutir sem eiga að vera saman ættu að vera saman og ættu að vera líkir. Þetta getur átt við allt frá listum, til upplýsinga í fæti til mynda og texta tengdum þeim.

![](../img/proximity.png "Listi með og án bils á milli hópa.")

### 2.28.2 Andstæður

Andstæður (contrast) myndast þegar hlutir eru ólíkir og ekki aðeins ólíkir heldur mjög ólíkir. Með þvi getum við dregið athygli að ákveðnum hlutum og brotið upp hönnun. Andstæður er hægt að mynda með því að nota mismunandi letur, mismunandi þyngd og mismunandi stærð. Við getum líka notað liti til að mynda andstæður, með því að snúa við litum á bakgrunni og letri.

![](../img/contrast.png "Dæmi um andstæður í fyrirsögnum.")

### 2.28.3 Letur

Letrið sem við notum skiptir máli. Ekki allar leturgerðir eru ekki gerðar til þess að vera á meginmáli og ekki allar eru gerðar til þess að vera í fyrirsögnum. Við ættum að velja leturgerðir sem bjóða upp á andstæður (hvort sem það er innan leturgerðar með mismunandi þyngd), henta efninu okkar og ekki of margar. Tvær leturgerðir ættu að vera nóg fyrir flest verkefni.

Stærð á letrinu okkar ætti ekki heldur að vera handahófskennt, fyrir fyrisagnir, meginmál og annan texta ættum við að skilgreina stærðir. Hægt er að útbúa _týpografískan skala_ sem skilgreinir stærðir á letri, svipar til tónlistarskala. T.d. er `12 14 16 18 21 24 36 48` skali sem oft er notaður fyrir letur.

Þegar við vinnum með fyrirsagnir og texta sem á einhvern hátt er dreginn út getur verið gott að huga að _kerning_ en það er þegar við eigum við pláss á milli hvers og eins stafs. Ef við höfum átt við `letter-spacing` eða erum að nota leturgerð sem ekki hefur gott pláss á milli stafa gætum við þurft að gera ráðstafanir svo að textinn okkar skiljist og orð ruglist ekki, t.d. getur `rn` runnið saman í `m` eða `LI` í `U`.

![](../img/keming.png "Slæmt kerning getur verið bagalegt.")

Það er síðan hægt að fara enn lengra með skala, letur og grind með því að skilgreina lóðrétta grind fyrir letur, svokallaðan _lóðréttan takt_ (vertical rhythm). Við gefum okkur þá pláss í grunninn sem _hver lína af texta_ þarf að passa innan margfeldis af, og ekki bara það heldur þurfa öll bil á milli texta (`margin`) að vera í margfeldi líka. T.d. ef við gefum okkur grunngildið `16px` þurfa allar línur að vera heilt, jákvætt margfeldi af því. Fyrirsögn passar t.d. innan `46px`, millifyrirsögn innan `32px` og meginmál innan `16px`. Hver lína innan þessarar láréttu grindar er kölluð _baseline_.

![](../img/vertical-rhythm.png "Dæmi um texta sem hefur lóðréttan takt.")

Allar þessar tilfærslur með letur eru ekki óþarfar; þær skapa sátt og jafnvægi.

### 2.28.4 Litir

Sama gildir um liti og letur, við ættum að ákveða litapallettu og nota hana. Ekki velja handahófskennda liti sem passa hugsanlega vel saman en hugsanlega ekki vel saman. Margar leiðir eru til þess að velja saman viðeigandi liti en margar þeirra snúast um að velja liti sem passa saman á litahjólinu. Til þess að velja þessa liti má nota tól einsog:

* [Adobe Color](https://color.adobe.com/)
* [Sessions collage: Color Calculator](https://www.sessions.edu/color-calculator/)

### 2.28.5 Veftré og wireframe

Áður en við förum beint _að hanna_ vef er mikilvægt að gera sér grein fyrir umfangi hans. Til þess að komast að því er gott að byrja á að því að setja upp _veftré_ en það er yfirlitsmynd yfir allar síður vefsins og hvernig þær tengjast innbyrðist.

![](../img/veftre.png "Dæmi um uppbyggingu á veftré.")

Með því að teikna upp veftré verður vefurinn og verkefnið sem við erum að fara að vinna skýrara og við sjáum jafnvel fram á hluti sem okkur hefði ekki dottið í hug. Ef við erum að vinna verkefnið með öðrum er þetta líka góð leið til þess að komast á sömu blaðsíðu um síður sem þarf að smíða og útbúa efni fyrir.

Wireframe er síðan það að taka hverja síðu (eða eina síðu fyrir hverja „síðutýpu“) og skissa upp hvernig hún mun líta út áður en farið er í beina hönnun. Þetta er hægt að gera með blað og blýanti, á tússtöflu eða í tóli (t.d. [balsamiq](https://balsamiq.com/)). Þetta gefur okkur tilfinningu fyrir því hvaða efni þurfi að vera á hverri síðu, í hvaða forgangi það eigi að vera og hvernig það tengist öðru efni.

![](../img/Profilewireframe.png "Dæmi um wireframe unnið í balsamiq. Mynd: https://upload.wikimedia.org/wikipedia/commons/4/47/Profilewireframe.png")

Þessi (ásamt mörgum öðrum mikilvægum verkefnum!) eru unnin af fólki sem sérhæfir sig í _notendaupplifunarhönnun_ (_UX design_ eða _user experience design_ ).

### 2.28.6 Bootstrap

Ef í harðbakkan slær og við treystum okkur ekki í að hanna okkar eigið útlit eru önnur tól sem geta hjálpað okkur. Eitt af þeim er [Bootstrap](https://getbootstrap.com/) sem er _framenda hlutasafn_ (frontend component library). Með Boostrap sníðum við HTML með ákveðnum klösum og fáum smekklegt útlit án mikils tilkostnaðar. Kostnaðurinn er þó helst sá að við fáum vef sem er mjög líkur mjög mörgum öðrum.

![](../img/bootstrap.png "Dæmi um útlit smíðað með Bootstrap.")

```html
<div class="jumbotron">
  <h1 class="display-3">Hello, world!</h1>
  <p class="lead">This is a template for a simple marketing or informational website. It includes a large callout called a jumbotron and three supporting pieces of content. Use it as a starting point to create something more unique.</p>
  <p class="lead">
    <a class="btn btn-primary btn-lg" href="#" role="button">Learn more</a>
  </p>
</div>
```

### 2.28.7 Nánar um hönnun

* [The Non-Designer's Design Book](https://www.goodreads.com/book/show/41597.The_Non_Designer_s_Design_Book) eftir Robin Williams
* [The Design of Everyday Things](https://www.goodreads.com/book/show/840.The_Design_of_Everyday_Things) eftir Donald A. Norman
* [Web Typography](http://book.webtypography.net/) eftir Richard Rutter

----

> Útgáfa 0.55, september 2018.
